<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èªéŸ³å ±è®€ç³»çµ±</title>
    <style>
	    html {
    touch-action: manipulation;
}
	     body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }

select, input, button {
  font-size: 18px; /* Increase font size for better readability */
  padding: 15px; /* Increase padding for larger touch targets */
  margin-bottom: 20px;
  border-radius: 8px; /* Add rounded corners for a modern look */
  border: 2px solid #ccc; /* Add border for better visibility */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add subtle shadow for depth */
}

select {
  width: 20%; /* Increase width for better usability */
  z-index: 1900;
  position: fixed;
  right: 20px;
  top:5px;
}
#pdfContainer {
  margin-top: 80px; /* è¨­å®šé ‚éƒ¨é‚Šè·ç‚º 80px */
}
  #prevPage, #nextPage {
    padding: 15px 30px; /* å¢åŠ å…§é‚Šè·ä»¥æ“´å¤§è§¸æ§å€åŸŸ */
    font-size: 18px; /* å¢åŠ å­—é«”å¤§å°ä»¥æé«˜å¯è®€æ€§ */
    cursor: pointer;
    background-color: #007BFF; /* æ·»åŠ èƒŒæ™¯è‰²ä»¥æé«˜å¯è¦‹æ€§ */
    color: white; /* å°‡æ–‡å­—é¡è‰²æ”¹ç‚ºç™½è‰² */
    border: none; /* ç§»é™¤é»˜èªé‚Šæ¡† */
    transition: background-color 0.3s; /* æ·»åŠ éæ¸¡æ•ˆæœä»¥æé«˜äº’å‹•æ€§ */
  }

  #prevPage:hover, #nextPage:hover {
    background-color: #0056b3; /* æ‡¸åœæ™‚æ›´æ”¹èƒŒæ™¯è‰² */
  }
audio {
    width: 50%;
    bottom: 5px;
    z-index: 1000;
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
}
        .pdf-page-container {
            margin-bottom: 20px;
            position: relative;
            display: inline-block;
        }
        .pdf-viewer {
            position: relative;
            display: inline-block;
        }
        /* å€å¡Šæ¨™è¨˜å±¤æ¨£å¼ */
        .mark-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* é»˜èªä¸æ¥æ”¶äº‹ä»¶ */
            z-index: 200; /* æé«˜ z-index ç¢ºä¿åœ¨æ–‡å­—å±¤ä¹‹ä¸Š */
            background-color: transparent; /* ç¢ºä¿èƒŒæ™¯é€æ˜ */
            overflow: visible; /* å…è¨±æ¨™è¨˜æ¡†è¶…å‡ºé‚Šç•Œ */
        }
        .mark-layer.marking-mode {
            pointer-events: auto; /* æ¨™è¨˜æ¨¡å¼æ™‚å…è¨±æ¥æ”¶äº‹ä»¶ */
        }
        .mark-layer .mark-block {
            pointer-events: auto; /* æ¨™è¨˜å€å¡Šå§‹çµ‚å¯é»æ“Š */
        }
        .mark-block {
            position: absolute;
            border: 3px solid #007BFF;
            background-color: rgba(0, 123, 255, 0.1);
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
            box-sizing: border-box;
            min-width: 10px;
            min-height: 10px;
        }
        .mark-block:hover {
            background-color: rgba(0, 123, 255, 0.2);
            border-color: #0056b3;
        }
        .mark-block.active {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.2);
        }
        .mark-block .mark-label {
            position: absolute;
            top: -20px;
            left: 0;
            background-color: #007BFF;
            color: white;
            padding: 2px 6px;
            font-size: 12px;
            border-radius: 3px;
            white-space: nowrap;
        }
        .mark-block.active .mark-label {
            background-color: #28a745;
        }
        .mark-block .mark-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: #dc3545;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            z-index: 1002;
            line-height: 1;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .mark-block .mark-delete:hover {
            background-color: #c82333;
        }
        .mark-layer.hidden {
            display: none !important;
        }
        /* ç¢ºä¿æ¨™è¨˜æ¡†åœ¨æ¨™è¨˜å±¤ä¸­å¯è¦‹ */
        .mark-layer.marking-mode {
            display: block !important;
            visibility: visible !important;
        }
        canvas {
            display: block;
        }
      .textLayer {
            position: absolute;
            text-align: initial;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
            -webkit-text-size-adjust: none;
            -webkit-transform-origin: 0% 0%;
            transform-origin: 0% 0%;
        }
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            pointer-events: auto;
        }
        .textLayer > span.highlight {
            background-color: transparent !important;
        }
        .textLayer > span[style*="background-color: rgba(255, 255, 0, 0.2)"] {
            background-color: transparent !important;
        }
        .textLayer > my-fra {
            background-color: transparent;
        }
        .textLayer > my-fra[style*="background-color: rgba(255, 255, 0, 0.2)"] {
            background-color: transparent !important;
        }
        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: rgba(180, 0, 170, 0.2);
            border-radius: 4px;
        }
        .textLayer .highlight.selected {
            background-color: rgba(0, 100, 0, 0.2);
        }
        .textLayer ::-moz-selection {
            background: rgba(0, 0, 255, 0.2);
        }
        .textLayer ::selection {
            background: rgba(0, 0, 255, 0.2);
        }
		  .no-select {
        user-select: none; /* ç¦ç”¨åç™½é¸å– */
        -webkit-user-select: none; /* ç¦ç”¨åç™½é¸å– for Safari */
        -moz-user-select: none; /* ç¦ç”¨åç™½é¸å– for Firefox */
        -ms-user-select: none; /* ç¦ç”¨åç™½é¸å– for Internet Explorer/Edge */
    }
    
    /* æ¨¡æ€çª—å£æ ·å¼ */
    .modal {
      display: none;
      /* é»˜è®¤éšè— */
      position: fixed;
      z-index: 900;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    /* æ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„ï¼ˆæ©«å‘ï¼Œç½®é ‚ï¼‰ */
    .marking-toolbar {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      background-color: rgba(255, 255, 255, 0.95);
      border-bottom: 2px solid #007BFF;
      padding: 10px 20px;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .marking-toolbar.show {
      display: flex;
    }
    
    .marking-toolbar .button {
      margin: 0;
      padding: 8px 16px;
      font-size: 14px;
      white-space: nowrap;
    }

    /* é®ç½©å±‚æ ·å¼ */
    .modal-overlay {
      display: none;
      /* é»˜è®¤éšè— */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.05);
      z-index: 900;
    }

    /* æŒ‰é’®æ ·å¼ */
    .button {
      padding: 10px 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .button-secondary {
      background-color: #6c757d;
    }

    .button-success {
      background-color: #28a745;
    }

    .button-light {
      background-color: #ded520;
    }

    .button-danger {
      background-color: #dc3545;
      
    }
     
   my-fra {
            display: inline; /* ç¢ºä¿ä¸å½±éŸ¿æ’ç‰ˆ */
        }
 input[type=range] {
    -webkit-appearance: none;
    width: 300px;
    height: 20px;
    background: linear-gradient(145deg, #d4d4d4, #f0f0f0);
    border: 1px solid #b0b0b0;
    border-radius: 10px;
    outline: none;
    opacity: 0.9;
    -webkit-transition: .2s;
    transition: opacity .2s;
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}

input[type=range]::-moz-range-thumb {
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}
   #verticalDiv {
            position: fixed;
            top: 200px; /* è·é›¢é ‚éƒ¨50px */
            right: 15px; /* è·é›¢å³å´0px */
            z-index: 1000;
            display: flex;
            flex-direction: column; /* ä½¿å…§å®¹ç¸±å‘æ’åˆ— */
            align-items: center; /* å…§å®¹ç½®ä¸­ */	
			
        }

        #speakSpeed {
		
            z-index: 1000;
            transform: rotate(-90deg); /* æ—‹è½‰æ»‘è»Œ */
            transform-origin: right center; /* è¨­ç½®æ—‹è½‰ä¸­å¿ƒ */

        }
    
    /* SweetAlert2 é«˜ z-index æ¨£å¼ */
    .swal-high-z-index {
        z-index: 10030 !important;
    }

    /* SweetAlert2 å…¨åŸŸé«˜ z-indexï¼Œç¢ºä¿æ°¸é åœ¨æœ€ä¸Šå±¤ï¼ˆé«˜æ–¼ API KEY æ¨¡æ…‹è¦–çª—çš„ 10020ï¼‰ */
    .swal2-container,
    .swal2-popup,
    .swal2-modal,
    .swal2-backdrop,
    .swal2-shown,
    .swal2-height-auto,
    .swal2-icon,
    .swal2-title,
    .swal2-content,
    .swal2-actions,
    .swal2-styled,
    .swal2-close,
    .swal2-validation-message,
    .swal2-html-container,
    .swal2-loader,
    .swal2-progress-steps,
    .swal2-backdrop-show,
    .swal2-backdrop-hide,
    .swal2-noanimation,
    .swal2-toast {
      z-index: 10030 !important;
    }
    </style>
	  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
</head>
<body tabindex="0">
	 <div class="container">
<div>
    <!-- è²éŸ³é¸æ“‡ -->  
    <select id="voiceSelect">
	é¸æ“‡è²éŸ³ï¼š
      <option value="zh-TW-HsiaoChenNeural">ä¸­æ–‡ï¼šæ›‰è‡» (å¥³æ€§)</option>
      <option value="zh-TW-YunJheNeural">ä¸­æ–‡ï¼šå…å“² (ç”·æ€§)</option>
      <option value="zh-TW-HsiaoYuNeural">ä¸­æ–‡ï¼šæ›‰é›¨ (å¥³æ€§)</option>
      <option value="en-US-JennyNeural">è‹±æ–‡ï¼šJenny (å¥³æ€§)</option>
      <option value="en-US-GuyNeural">è‹±æ–‡ï¼šGuy (ç”·æ€§)</option>
      <option value="en-US-AriaNeural">è‹±æ–‡ï¼šAria (å¥³æ€§)</option>
      <option value="en-US-ChristopherNeural">è‹±æ–‡ï¼šChrist (ç”·æ€§)</option> 
    </select>
</div>
		  <!-- èªé€Ÿèª¿æ•´ -->
 <div id="verticalDiv">	     
      <label for="speakSpeed" style="writing-mode: vertical-lr; position: fixed; top: 120px; right: 5px; color: rgb(134, 101, 224); font-size: 20px; font-weight: bold; text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px; height: 200px; display: flex; align-items: center;">
    <span id="speedLabel">èªé€ŸåŠ </span>
    <span id="speedPercent" style="writing-mode: horizontal-tb; margin-left: 5px;">0%</span>
</label>
      <input type="range" id="speakSpeed" name="rate" min="-50" max="50" value="-30" oninput="updateRate(this.value)" style="  width:20%;  padding: 10px;  margin-bottom: 20px; z-index:1000;right:15px;position: fixed;">
    </div>
    
    <!-- éŸ³é »æ’­æ”¾å™¨ -->
    <audio id="audioPlayer" controls></audio>
  </div>
<div id="movable-frame"></div>
<input type="file" id="pdfFileInput" style=" width: 20%; /* Increase width for better usability */  z-index: 1900;  position: fixed;  left: 20px; top:5px;">
<div id="viewerContainer" tabindex="0">
    <center><div id="pdfContainer"></div></center>
</div>
	
<div class="pagination" style="width: 100%; top: 5px; z-index: 1000;  position: fixed;">
	<center>
    <button id="prevPage">ä¸Šä¸€é </button>
    <span id="pageNumber"></span>
    <button id="nextPage">ä¸‹ä¸€é </button>
	</center>	
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>    
  <button id="select-all-text" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;z-index: 2000;position: fixed; bottom: 5px;right: 0%; z-index: 1100;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;" >æ•´é æœ—è®€</button>
  <!-- é¡µé¢é®ç½© -->
  <div id="modalOverlay" class="modal-overlay"></div>

   <button id="sendButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;right: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">æœ—è®€é¸å–æ–‡å­—</button>
  <button id="clearButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;left: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">æ¸…é™¤é¸å–æ–‡å­—</button>
    <label style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; top: 300px;left: 2px; z-index: 1000;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;">
        <input type="checkbox" id="touchSelectCheckbox" style="writing-mode: vertical-rl; text-orientation: upright; width: 30px; height: 30px; position: fixed;left: 1px;top: 260px;">è§¸æ§é¸å–</label>
    <!-- æ–°å¢ï¼šæ‰‹å‹•æ¸…é™¤å¿«å–æŒ‰éˆ• -->
    <button id="clearCacheButton" class="button button-danger" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; left: 0px; top: 450px; z-index: 1100; font-size: 16px;">æ¸…é™¤å¿«å–</button>
    
    <!-- API KEY è¨­å®šæŒ‰éˆ• -->
    <button id="apiKeySettingsButton" class="button button-secondary" style="position: fixed; top: 70px; left: 0px; z-index: 1; width: 40px; height: 40px; border-radius: 50%; padding: 0; font-size: 20px; display: flex; align-items: center; justify-content: center;" title="è¨­å®š Gemini API KEY">ğŸ”‘</button>

    <!-- API KEY è¨­å®šæ¨¡æ…‹è¦–çª—ï¼ˆåŒ…å«æ¨™è¨˜åŠŸèƒ½ï¼‰ -->
    <div id="apiKeyModal" class="modal" style="display: none; z-index: 10020;">
        <div style="padding: 20px;">
            <h2 style="margin-top: 0;">è¨­å®šåœ–ç‰‡è¾¨è­˜ç”¨çš„ Gemini API KEY</h2>
            <div style="margin-bottom: 15px;">
                <label for="apiKeyInput" style="display: block; margin-bottom: 5px; font-weight: bold;">API KEYï¼š</label>
                <input type="password" id="apiKeyInput" placeholder="è«‹è¼¸å…¥æˆ–æƒæ QR Code" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 15px;">
                <button id="scanQRButton" class="button button-success" style="width: 100%; margin-bottom: 10px;">ğŸ“· æƒæ QR Code</button>
                <div id="qrScannerContainer" style="display: none; margin-bottom: 15px;">
                    <video id="qrVideo" style="width: 100%; max-width: 400px; border: 2px solid #ccc; border-radius: 5px; display: block; margin: 0 auto;"></video>
                    <canvas id="qrCanvas" style="display: none;"></canvas>
                    <button id="stopScanButton" class="button button-danger" style="width: 100%; margin-top: 10px;">åœæ­¢æƒæ</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                <button id="saveApiKeyButton" class="button button-success" style="flex: 1;">å„²å­˜</button>
                <button id="deleteApiKeyButton" class="button button-danger" style="flex: 1;">åˆªé™¤ API KEY</button>
                <button id="cancelApiKeyButton" class="button button-secondary" style="flex: 1;">å–æ¶ˆ</button>
            </div>
            
            <!-- åˆ†éš”ç·š -->
            <hr style="margin: 20px 0; border: none; border-top: 2px solid #ccc;">
            
            <!-- å€å¡Šæ¨™è¨˜åŠŸèƒ½ -->
            <h3 style="margin-top: 0; margin-bottom: 15px;">PDF æ¨™è¨˜åŠŸèƒ½</h3>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button id="markBlockButton" class="button button-success" style="width: 100%; font-size: 16px;">æ¨™è¨˜å€å¡Š</button>
                <button id="saveMarkedPdfButton" class="button button-success" style="width: 100%; font-size: 16px; display: none;">ä¿å­˜æ¨™è¨˜</button>
                <button id="downloadMarkedPdfButton" class="button button-success" style="width: 100%; font-size: 16px; display: none;">ä¸‹è¼‰PDF</button>
                <button id="clearMarksButton" class="button button-danger" style="width: 100%; font-size: 16px; display: none;">æ¸…é™¤æ¨™è¨˜</button>
            </div>
        </div>
    </div>
    <div id="apiKeyModalOverlay" class="modal-overlay" style="z-index: 10019;"></div>
    
    <!-- æ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„ï¼ˆæ©«å‘ï¼Œç½®é ‚ï¼Œä¸æ“‹ä½PDFï¼‰ -->
    <div id="markingToolbar" class="marking-toolbar">
        <button id="markBlockButtonToolbar" class="button button-success">æ¨™è¨˜å€å¡Š</button>
        <button id="saveMarkedPdfButtonToolbar" class="button button-success" style="display: none;">ä¿å­˜æ¨™è¨˜</button>
        <button id="downloadMarkedPdfButtonToolbar" class="button button-success" style="display: none;">ä¸‹è¼‰PDF</button>
        <button id="clearMarksButtonToolbar" class="button button-danger" style="display: none;">æ¸…é™¤æ¨™è¨˜</button>
    </div>

<button  class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;z-index: 2000;position: fixed; bottom: 5px;left: 0%; z-index: 1100;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;" onclick="redirectToNewPage()">åˆ‡æ›è¼‰å…·èªéŸ³</button>
<script>
// ç§»é™¤ BroadcastChannel ç›¸é—œä»£ç¢¼ï¼Œæ›¿æ›ç‚ºä»¥ä¸‹å¯¦ç¾

// é æ•¸åŒæ­¥ç›¸é—œè®Šé‡
let pageSyncTimeout = null;
const PAGE_SYNC_DELAY = 300; // é˜²æŠ–å»¶é²(æ¯«ç§’)

// ä¿®æ”¹ notifyPageChange å‡½æ•¸
function notifyPageChange(page) {
    // æ›´æ–° URL hash
    updateUrlHash(page);
    
    // å¦‚æœæ˜¯ iframe å…§åµŒçš„æƒ…æ³ï¼Œé€šçŸ¥çˆ¶çª—å£
    if (window !== window.top) {
        window.parent.postMessage({
            type: 'pageChange',
            page: page,
            source: 'pdfViewer'
        }, '*'); // æ³¨æ„: å¯¦éš›æ‡‰ç”¨ä¸­æ‡‰æŒ‡å®šå…·é«”åŸŸåè€Œé '*'
    }
    
    // æ›´æ–° localStorage
    localStorage.setItem('currentPage', page);
}

//  æ›´æ–°URL hash (ä¸è§¸ç™¼é é¢åˆ·æ–°)
function updateUrlHash(page) {
    const newUrl = new URL(window.location.href);
    newUrl.hash = `page=${page}`;
    window.history.replaceState({}, '', newUrl);
}
// ç²å–ç•¶å‰é æ•¸ (å¾URL hashæˆ–localStorage)
function getPageFromHash() {
    const hash = window.location.hash.substring(1);
    const params = new URLSearchParams(hash);
    const pageFromHash = params.get('page') ? parseInt(params.get('page')) : null;
    
    // å¾ localStorage è®€å–ä½œç‚ºå‚™ç”¨
    const pageFromStorage = localStorage.getItem('currentPage') ? parseInt(localStorage.getItem('currentPage')) : 1;
    
    return pageFromHash || pageFromStorage;
}
// åˆ‡æ›ç¶²è·¯èªéŸ³æ™‚ä¿ç•™ç•¶å‰æª”æ¡ˆå’Œé æ•¸
function redirectToNewPage() {
    const urlParams = new URLSearchParams(window.location.search);
    const params = new URLSearchParams();
    
    // ä¿ç•™æ‰€æœ‰ç¾æœ‰åƒæ•¸
    if (urlParams.get('file')) params.set('file', urlParams.get('file'));
    if (urlParams.get('googlesheetid')) params.set('googlesheetid', urlParams.get('googlesheetid'));
    
    // æ§‹å»ºæ–°URL
    let newUrl = 'localvoice.html';
    if (params.toString()) newUrl += `?${params.toString()}`;
    
    // ä¿ç•™ç•¶å‰é æ•¸
    const currentPage = getPageFromHash();
    if (currentPage > 1) newUrl += `#page=${currentPage}`;
    
    window.location.href = newUrl;
}
// PDF.js åˆå§‹åŒ–
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

const pdfFileInput = document.getElementById('pdfFileInput');
const pdfContainer = document.getElementById('pdfContainer');
const prevPageButton = document.getElementById('prevPage');
const nextPageButton = document.getElementById('nextPage');
const pageNumberSpan = document.getElementById('pageNumber');

let pdfDoc = null;
let currentPage = 1;

// Function to render the page with dynamic width
function renderPage(pageNum) {
    if (!pdfDoc) return;

    pdfDoc.getPage(pageNum).then(page => {
        const screenWidth = window.innerWidth;
        const desiredWidth = screenWidth * 0.95; // Keep 95% width
        const viewport = page.getViewport({ scale: 1 });
        const scale = desiredWidth / viewport.width;
        const scaledViewport = page.getViewport({ scale: scale });

        pdfContainer.innerHTML = '';

        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';
        pageContainer.style.position = 'relative';

        const pdfViewer = document.createElement('div');
        pdfViewer.className = 'pdf-viewer';
        pdfViewer.style.position = 'relative';

        const pdfCanvas = document.createElement('canvas');
        const context = pdfCanvas.getContext('2d');

        const dpi = window.devicePixelRatio || 1;
        pdfCanvas.height = scaledViewport.height * dpi;
        pdfCanvas.width = scaledViewport.width * dpi;
        context.scale(dpi, dpi);

        pdfCanvas.style.height = `${scaledViewport.height}px`;
        pdfCanvas.style.width = `${scaledViewport.width}px`;
        pdfCanvas.style.display = 'block';

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.style.width = `${scaledViewport.width}px`;
        textLayerDiv.style.height = `${scaledViewport.height}px`;
        textLayerDiv.style.position = 'absolute';
        textLayerDiv.style.top = '0';
        textLayerDiv.style.left = '0';
        textLayerDiv.style.pointerEvents = 'none';

        // å‰µå»ºæ¨™è¨˜å±¤
        const markLayer = document.createElement('div');
        markLayer.className = 'mark-layer';
        markLayer.style.width = `${scaledViewport.width}px`;
        markLayer.style.height = `${scaledViewport.height}px`;
        markLayer.dataset.pageNum = pageNum;
        markLayer.dataset.scale = scale;

        pageContainer.appendChild(pdfViewer);
        pdfViewer.appendChild(pdfCanvas);
        pdfViewer.appendChild(textLayerDiv);
        pdfViewer.appendChild(markLayer);
        pdfContainer.appendChild(pageContainer);
        
        // å¦‚æœè™•æ–¼æ¨™è¨˜æ¨¡å¼ï¼Œç‚º pdfViewer ç¶å®šäº‹ä»¶
        if (isMarkingMode) {
            pdfViewer.addEventListener('mousedown', handleViewerMouseDown);
            pdfViewer.addEventListener('touchstart', handleViewerTouchStart);
        }

        const renderContext = {
            canvasContext: context,
            viewport: scaledViewport
        };

        page.render(renderContext).promise.then(() => {
            return page.getTextContent();
        }).then(textContent => {
            textLayerDiv.innerHTML = '';
            pdfjsLib.renderTextLayer({
                textContent: textContent,
                container: textLayerDiv,
                viewport: scaledViewport,
                textDivs: [],
                enhanceTextSelection: true
            });

            // ä¿®æ­£æ–‡å­—å±¤çš„ç¸®æ”¾å’Œä½ç½®
            const textElements = textLayerDiv.getElementsByTagName('span');
            for (let span of textElements) {
                const originalTransform = span.style.transform || '';
                span.style.transform = originalTransform.replace(/scale\([^)]+\)/, `scale(${1/dpi})`);
            }
            
            // åœ¨æ–‡å­—å±¤æ¸²æŸ“å®Œæˆå¾Œï¼Œå»¶é²æ¸²æŸ“æ¨™è¨˜
            setTimeout(() => {
                renderMarks();
                // å¦‚æœè™•æ–¼æ¨™è¨˜æ¨¡å¼ï¼Œç¢ºä¿æ¨™è¨˜å±¤äº‹ä»¶å·²å•Ÿç”¨
                if (isMarkingMode) {
                    const markLayer = document.querySelector(`.mark-layer[data-page-num="${pageNum}"]`);
                    const pdfViewer = document.querySelector('.pdf-viewer');
                    if (markLayer) {
                        markLayer.classList.add('marking-mode');
                    }
                    if (pdfViewer) {
                        pdfViewer.addEventListener('mousedown', handleViewerMouseDown);
                        pdfViewer.addEventListener('touchstart', handleViewerTouchStart);
                    }
                }
            }, 300);
        });

        pageNumberSpan.textContent = `Page ${pageNum} of ${pdfDoc.numPages}`;

        const currentHash = window.location.hash;
        const newHash = `page=${pageNum}`;
        if (currentHash !== newHash) {
            const newUrl = new URL(window.location.href);
            newUrl.hash = newHash;
            window.history.replaceState({}, '', newUrl);
        }
    });
}

// Event listener for orientation changes
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        renderPage(currentPage);
    }, 200); // Delay of 200 milliseconds
});

// Initial render
renderPage(currentPage);
	
// Google Apps Script ä»£ç† URL
const gasUrl = 'https://script.google.com/macros/s/AKfycbz22gIlfLOry1KdMW5A2NlcO1o9859zXGP1Yf0GklsNbU4VF-WBRJtW2sGL8rZIE1oq/exec';


// æ‰“é–‹ IndexedDB è³‡æ–™åº«
const openDB = () => {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('pdfDB', 3); // å¢åŠ ç‰ˆæœ¬è™Ÿä»¥è§¸ç™¼å‡ç´š
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            // å¦‚æœ objectStore å·²å­˜åœ¨ï¼Œå…ˆåˆªé™¤å†é‡æ–°å‰µå»ºä»¥ç¢ºä¿é…ç½®æ­£ç¢º
            if (db.objectStoreNames.contains('pdfFiles')) {
                db.deleteObjectStore('pdfFiles');
            }
            // é‡æ–°å‰µå»º objectStoreï¼Œç¢ºä¿ä½¿ç”¨ keyPath: 'id'
            db.createObjectStore('pdfFiles', { keyPath: 'id' });
            
            // å‰µå»ºè¨­å®š objectStoreï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!db.objectStoreNames.contains('settings')) {
                db.createObjectStore('settings', { keyPath: 'id' });
            }
        };
        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = (e) => reject(e.target.error);
    });
};

// ä¿å­˜æª”æ¡ˆåˆ° IndexedDB
const saveFileToIndexedDB = async (file) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        
        // ç¢ºä¿å°è±¡æœ‰ id å±¬æ€§ï¼Œä¸¦ç­‰å¾… put æ“ä½œå®Œæˆ
        const dataToStore = { id: 'currentPdf', file: file };
        const putRequest = store.put(dataToStore);
        
        return new Promise((resolve, reject) => {
            putRequest.onsuccess = () => {
                // put æ“ä½œæˆåŠŸï¼Œç­‰å¾… transaction å®Œæˆ
            };
            putRequest.onerror = () => reject(putRequest.error);
            
            // ç›£è½ transaction å®Œæˆ
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    } catch (error) {
        console.error('ä¿å­˜æª”æ¡ˆåˆ° IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// å¾ IndexedDB è®€å–æª”æ¡ˆ
const loadFileFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readonly');
        const store = transaction.objectStore('pdfFiles');
        const request = store.get('currentPdf');
        return new Promise((resolve, reject) => {
            request.onsuccess = (e) => {
                if (e.target.result) {
                    resolve(e.target.result.file);
                } else {
                    reject(new Error('IndexedDB ä¸­æœªæ‰¾åˆ°æª”æ¡ˆ'));
                }
            };
            request.onerror = (e) => reject(e.target.error);
        });
    } catch (error) {
        console.error('å¾ IndexedDB è®€å–æª”æ¡ˆå¤±æ•—ï¼š', error);
        throw error;
    }
};

// æ¸…ç©º IndexedDB ä¸­çš„æª”æ¡ˆ
const clearIndexedDB = async (forceClear = false) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        if (forceClear) {
            store.delete('currentPdf');
        }
        updateUrl(null);
    } catch (error) {
        console.error('æ¸…é™¤ IndexedDB å¤±æ•—ï¼š', error);
    }
};

// ä¿å­˜ API KEY åˆ° IndexedDB
const saveApiKeyToIndexedDB = async (apiKey) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readwrite');
        const store = transaction.objectStore('settings');
        const dataToStore = { id: 'geminiApiKey', value: apiKey };
        const putRequest = store.put(dataToStore);
        
        return new Promise((resolve, reject) => {
            putRequest.onsuccess = () => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            putRequest.onerror = () => reject(putRequest.error);
        });
    } catch (error) {
        console.error('ä¿å­˜ API KEY åˆ° IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// å¾ IndexedDB è®€å– API KEY
const loadApiKeyFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readonly');
        const store = transaction.objectStore('settings');
        const request = store.get('geminiApiKey');
        return new Promise((resolve, reject) => {
            request.onsuccess = (e) => {
                if (e.target.result) {
                    resolve(e.target.result.value);
                } else {
                    resolve(null);
                }
            };
            request.onerror = (e) => reject(e.target.error);
        });
    } catch (error) {
        console.error('å¾ IndexedDB è®€å– API KEY å¤±æ•—ï¼š', error);
        return null;
    }
};

// åˆªé™¤ API KEY å¾ IndexedDB
const deleteApiKeyFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readwrite');
        const store = transaction.objectStore('settings');
        const deleteRequest = store.delete('geminiApiKey');
        
        return new Promise((resolve, reject) => {
            deleteRequest.onsuccess = () => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            deleteRequest.onerror = () => reject(deleteRequest.error);
        });
    } catch (error) {
        console.error('åˆªé™¤ API KEY å¾ IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// æ›´æ–°ç¶²å€ä¸­çš„æª”æ¡ˆåç¨±

function updateUrl(fileName) {
    const newUrl = new URL(window.location.href);
    if (fileName) {
        newUrl.searchParams.set('file', fileName); // ä¸ä½¿ç”¨ encodeURIComponent
    } else {
        newUrl.searchParams.delete('file');
    }
    window.history.replaceState({}, '', newUrl);
}

// å¾ URL è¼‰å…¥ PDF æª”æ¡ˆ
async function loadPdfFromUrl(url) {
    try {
        Swal.fire({
            title: 'è¼‰å…¥ä¸­è«‹ç¨å€™',
            text: 'æ­£åœ¨å¾ç¶²è·¯è¼‰å…¥æª”æ¡ˆ...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });
        
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTPéŒ¯èª¤: ${response.status}`);
        }
        
        const arrayBuffer = await response.arrayBuffer();
        originalPdfBytes = new Uint8Array(arrayBuffer);
        
        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
        const fileName = url.split('/').pop() || 'document.pdf';
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        const typedarray = new Uint8Array(arrayBuffer);
        // ä¿å­˜åŸå§‹PDFå­—ç¯€ï¼ˆç”¨æ–¼ä¿å­˜æ¨™è¨˜ï¼‰
        originalPdfBytes = typedarray;
        
        pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
            pdfDoc = pdf;
            currentPage = 1;
            renderPage(currentPage);
            // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
            setTimeout(async () => {
                await loadMarksFromPdf();
            }, 800);
            updateUrl(url);
            Swal.close();
        }).catch(error => {
            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'è¼‰å…¥å¤±æ•—',
                text: 'ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥URLæ˜¯å¦æ­£ç¢ºã€‚',
            });
        });
    } catch (error) {
        console.error('å¾URLè¼‰å…¥PDFå¤±æ•—ï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'è¼‰å…¥å¤±æ•—',
            text: 'ç„¡æ³•å¾URLè¼‰å…¥PDFæª”æ¡ˆï¼š' + error.message,
        });
    }
}

// å¾ Google é›²ç«¯ç¡¬ç¢Ÿè¼‰å…¥ PDF æª”æ¡ˆï¼ˆä½¿ç”¨ GAS ä»£ç†ï¼‰
async function loadPdfFromDrive(fileId, showLoading = true) {
    // æª¢æŸ¥æ˜¯å¦æ˜¯æœ¬åœ°æª”æ¡ˆåç¨±ï¼ˆåŒ…å« .pdf çµå°¾ï¼‰
    if (fileId && fileId.toLowerCase().endsWith('.pdf')) {
        // å¦‚æœæ˜¯æœ¬åœ°æª”æ¡ˆåç¨±ï¼Œç›´æ¥è¿”å›ä¸è™•ç†
        return;
    }

    if (showLoading) {
        Swal.fire({
            title: 'è¼‰å…¥ä¸­è«‹ç¨å€™',
            text: 'æ­£åœ¨å¾é›²ç«¯ç¡¬ç¢Ÿè¼‰å…¥æª”æ¡ˆ...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });
    }

    let fileName = `file_${fileId}.pdf`;
    
    // å‰µå»ºå¸¶è¶…æ™‚çš„ fetch å‡½æ•¸
    const fetchWithTimeout = (url, options = {}, timeout = 10000) => {
        return Promise.race([
            fetch(url, options),
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('è«‹æ±‚è¶…æ™‚')), timeout)
            )
        ]);
    };
    
    try {
        // ä½¿ç”¨ GAS ä»£ç†ä¸‹è¼‰
        console.log('ä½¿ç”¨ GAS ä»£ç†ä¸‹è¼‰æª”æ¡ˆ...');
        const gasResponse = await fetchWithTimeout(
            `${gasUrl}?fileId=${fileId}`, 
            { method: 'GET' }, 
            10000
        );
        
        if (!gasResponse.ok) {
            throw new Error(`GAS ä»£ç†å›æ‡‰éŒ¯èª¤: ${gasResponse.status} ${gasResponse.statusText}`);
        }
        
        const data = await gasResponse.json();
        
        if (!data.fileContent || !data.fileName) {
            throw new Error('GAS ä»£ç†è¿”å›çš„è³‡æ–™æ ¼å¼éŒ¯èª¤');
        }
        
        // GAS è¿”å› base64 ç·¨ç¢¼çš„å…§å®¹
        const fileContent = atob(data.fileContent);
        const arrayBuffer = new ArrayBuffer(fileContent.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < fileContent.length; i++) {
            uint8Array[i] = fileContent.charCodeAt(i);
        }
        fileName = data.fileName;
        
        console.log(`âœ“ ä¸‹è¼‰æˆåŠŸï¼Œä¾†æº: GAS ä»£ç†`);
        
        // å°‡ ArrayBuffer è½‰æ›ç‚º File ä¸¦ä¿å­˜
        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        // ä¿å­˜åŸå§‹PDFå­—ç¯€
        originalPdfBytes = new Uint8Array(arrayBuffer);
        
        // è¼‰å…¥ PDF
        const typedarray = new Uint8Array(arrayBuffer);
        // ä¿å­˜åŸå§‹PDFå­—ç¯€ï¼ˆç”¨æ–¼ä¿å­˜æ¨™è¨˜ï¼‰
        originalPdfBytes = typedarray;
        
        pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
            pdfDoc = pdf;
            renderPage(currentPage);
            // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
            setTimeout(async () => {
                await loadMarksFromPdf();
            }, 800);
            updateUrl(fileId);
            if (showLoading) {
                Swal.close();
            }
        }).catch(error => {
            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'è¼‰å…¥å¤±æ•—',
                text: 'ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚',
            });
        });
    } catch (error) {
        console.error('GAS ä»£ç†ä¸‹è¼‰å¤±æ•—ï¼š', error);
        if (showLoading) {
            Swal.fire({
                icon: 'error',
                title: 'ä¸‹è¼‰å¤±æ•—',
                text: 'ç„¡æ³•å¾ Google é›²ç«¯ç¡¬ç¢Ÿä¸‹è¼‰æª”æ¡ˆã€‚\n\n' +
                    'å¯èƒ½çš„åŸå› ï¼š\n' +
                    '1. æª”æ¡ˆæœªå…¬é–‹åˆ†äº«ï¼ˆè«‹ç¢ºèªæª”æ¡ˆåˆ†äº«è¨­å®šç‚ºã€ŒçŸ¥é“é€£çµçš„ä½¿ç”¨è€…ã€ï¼‰\n' +
                    '2. GAS ä»£ç†æœå‹™ç•°å¸¸\n' +
                    '3. ç¶²è·¯é€£ç·šå•é¡Œ\n\n' +
                    'å»ºè­°ï¼š\n' +
                    '- ç¢ºèªæª”æ¡ˆå·²å…¬é–‹åˆ†äº«\n' +
                    '- æª¢æŸ¥ç¶²è·¯é€£ç·š\n' +
                    '- ç¨å¾Œå†è©¦',
            });
        }
    }
}
// ç•¶é é¢è¼‰å…¥æ™‚ï¼Œæª¢æŸ¥ç¶²å€ä¸­çš„æª”æ¡ˆåç¨±

// ä¿®æ”¹é é¢åˆå§‹åŒ–éƒ¨åˆ†
window.addEventListener('load', async () => {
    // å¾ URL hash æˆ– localStorage è®€å–åˆå§‹é æ•¸
    currentPage = getPageFromHash();
    
    // åŸæœ‰çš„åˆå§‹åŒ–ä»£ç¢¼...
    const urlParams = new URLSearchParams(window.location.search);
    const fileParam = urlParams.get('file');
    const previousUrl = sessionStorage.getItem('previousUrl');
    const currentUrl = window.location.href;

    // åˆ¤æ–·æ˜¯å¦ç‚ºé é¢é‡æ–°æ•´ç†
    const isPageRefresh = previousUrl === currentUrl;

    // åˆ¤æ–· URL æ˜¯å¦ä»¥ .pdf çµå°¾ï¼ˆæœ¬åœ°æª”æ¡ˆï¼‰
    const isLocalPdfFile = fileParam && fileParam.toLowerCase().endsWith('.pdf');

    if (fileParam) {
        if (fileParam.startsWith('http://') || fileParam.startsWith('https://')) {
            // è™•ç†ç¶²è·¯ PDF æª”æ¡ˆ
            await clearIndexedDB();
            loadPdfFromUrl(fileParam);
        } else if (isLocalPdfFile) {
            // è™•ç†æœ¬åœ° PDF æª”æ¡ˆ
            try {
                const file = await loadFileFromIndexedDB();
                if (file && file.name === fileParam) {
                    console.log('ç•¶å‰æª”æ¡ˆèˆ‡ URL ä¸­çš„æœ¬åœ°æª”æ¡ˆç›¸åŒï¼Œå¾ IndexedDB è¼‰å…¥');
                    const fileReader = new FileReader();
                    fileReader.onload = function() {
                        const typedarray = new Uint8Array(this.result);
                        originalPdfBytes = typedarray;
                        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                            pdfDoc = pdf;
                            renderPage(currentPage);
                            // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
                            setTimeout(() => {
                                loadMarksFromPdf();
                            }, 800);
                        }).catch(error => {
                            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                            alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                        });
                    };
                    fileReader.onerror = function() {
                        console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                        alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
                    };
                    fileReader.readAsArrayBuffer(file);
                } else {
                    console.log('IndexedDB ä¸­æ²’æœ‰åŒ¹é…çš„æœ¬åœ°æª”æ¡ˆï¼Œæ¸…é™¤ URL åƒæ•¸');
                    updateUrl(null);
                }
            } catch (error) {
                console.error('è®€å–æœ¬åœ°æª”æ¡ˆå¤±æ•—ï¼š', error);
                updateUrl(null);
            }
        } else {
            // è™•ç† Google é›²ç«¯ç¡¬ç¢Ÿæª”æ¡ˆ
            try {
                const file = await loadFileFromIndexedDB();
                if (file) {
                    if (file.name === fileParam) {
                        console.log('ç•¶å‰æª”æ¡ˆèˆ‡ URL ä¸­çš„æª”æ¡ˆç›¸åŒï¼Œè·³éé‡æ–°è¼‰å…¥ã€‚');
                        const fileReader = new FileReader();
                        fileReader.onload = async function() {
                            const typedarray = new Uint8Array(this.result);
                            originalPdfBytes = typedarray;
                            pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
                                pdfDoc = pdf;
                                renderPage(currentPage);
                                // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
                                setTimeout(async () => {
                                    await loadMarksFromPdf();
                                }, 800);
                            }).catch(error => {
                                console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                                alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                            });
                        };
                        fileReader.onerror = function() {
                            console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                            alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
                        };
                        fileReader.readAsArrayBuffer(file);
                    } else {
                        await clearIndexedDB();
                        await saveFileToIndexedDB(file);
                        updateUrl(file.name);
                    }
                } else {
                    await loadPdfFromDrive(fileParam, !isPageRefresh);
                }
            } catch (error) {
                console.error('è®€å–æª”æ¡ˆå¤±æ•—ï¼š', error);
                await loadPdfFromDrive(fileParam, !isPageRefresh);
            }
        }
    }

    // æ›´æ–° sessionStorage ä¸­çš„ previousUrl
    sessionStorage.setItem('previousUrl', currentUrl);
});

//  ç›£è½é æ•¸è®ŠåŒ–äº‹ä»¶
window.addEventListener('hashchange', function() {
    const newPage = getPageFromHash();
    if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
        currentPage = newPage;
        renderPage(currentPage);
    }
});

// ç•¶ä½¿ç”¨è€…é¸æ“‡æª”æ¡ˆæ™‚
pdfFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        try {
            await clearIndexedDB(true);
            await saveFileToIndexedDB(file);
            
            // æ›´æ–° URL åƒæ•¸ï¼Œæ¨™è¨˜ç‚ºæœ¬åœ°æª”æ¡ˆ
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('file', file.name);
            window.history.replaceState({}, '', newUrl);
            
            const fileReader = new FileReader();
            fileReader.onload = async function() {
                const typedarray = new Uint8Array(this.result);
                // ä¿å­˜åŸå§‹PDFå­—ç¯€ï¼ˆç”¨æ–¼ä¿å­˜æ¨™è¨˜ï¼‰
                originalPdfBytes = typedarray;
                
                pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
                    pdfDoc = pdf;
                    currentPage = 1; // é‡ç½®ç‚ºç¬¬ä¸€é 
                    renderPage(currentPage);
                    // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
                    setTimeout(async () => {
                        await loadMarksFromPdf();
                    }, 800);
                }).catch(error => {
                    console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                    alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                });
            };
            fileReader.onerror = function() {
                console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
            };
            fileReader.readAsArrayBuffer(file);
        } catch (error) {
            console.error('ä¿å­˜æª”æ¡ˆå¤±æ•—ï¼š', error);
            alert('ä¿å­˜æª”æ¡ˆå¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
        }
    } else {
        updateUrl(null);
    }
});

// ä¸Šä¸€é å’Œä¸‹ä¸€é æŒ‰éˆ•çš„äº‹ä»¶ç›£è½
// ä¿®æ”¹ä¸Šä¸€é /ä¸‹ä¸€é æŒ‰éˆ•äº‹ä»¶
prevPageButton.addEventListener('click', () => {
    if (currentPage > 1) {
        currentPage--;
        renderPage(currentPage);
        setTimeout(() => {
            renderMarks();
        }, 500);
        notifyPageChange(currentPage);
    }
});

nextPageButton.addEventListener('click', () => {
    if (pdfDoc && currentPage < pdfDoc.numPages) {
        currentPage++;
        renderPage(currentPage);
        setTimeout(() => {
            renderMarks();
        }, 500);
        notifyPageChange(currentPage);
    }
});
// ç›£è½è·¨ç¶²åŸŸæ¶ˆæ¯
window.addEventListener('message', function(event) {
    if (event.data?.type === 'pageChange' && event.data.source !== 'pdfViewer') {
        const newPage = event.data.page;
        if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
            currentPage = newPage;
            renderPage(currentPage);
            updateUrlHash(currentPage);
        }
    }
});


// å¾ URL åƒæ•¸ä¸­è®€å– PDF æª”æ¡ˆçš„ ID
const urlParams = new URLSearchParams(window.location.search);
const fileId = urlParams.get('file');
if (fileId) {
    loadPdfFromDrive(fileId);
}
// æ–°å¢ï¼šæ‰‹å‹•æ¸…é™¤å¿«å–æŒ‰éˆ•åŠŸèƒ½
const clearCacheButton = document.getElementById('clearCacheButton');
if (clearCacheButton) {
    clearCacheButton.addEventListener('click', async () => {
        await clearIndexedDB(true);
        Swal.fire({
            icon: 'success',
            title: 'å·²æ¸…é™¤PDFå¿«å–',
            text: 'PDF å¿«å–å·²æ¸…é™¤ï¼Œè«‹é‡æ–°è¼‰å…¥æª”æ¡ˆã€‚',
            timer: 1500,
            showConfirmButton: false
        });
    });
}
</script>
 <script>
  
  // API é…ç½®
  const API_CONFIG = {
    BASE_URL: 'https://readtts-tts.hf.space', // Hugging Face Spaces TTS API
    TTS_ENDPOINT: '/tts',
    VOICES_ENDPOINT: '/voices'
  };
  
  // API å¥åº·æª¢æŸ¥
  async function checkAPIHealth() {
    try {
      const response = await fetch(`${API_CONFIG.BASE_URL}/health`);
      if (response.ok) {
        console.log('âœ… Edge TTS API æœå‹™æ­£å¸¸é‹è¡Œ');
        return true;
      } else {
        console.warn('âš ï¸ Edge TTS API æœå‹™å¯èƒ½æœªæ­£å¸¸é‹è¡Œ');
        return false;
      }
    } catch (error) {
      console.error('âŒ ç„¡æ³•é€£æ¥åˆ° Edge TTS API æœå‹™:', error);
      return false;
    }
  }
  
  let selectedFile = null;
  let isListening = true; // åˆå§‹è¨­ç½®ç‚ºç›£è½æ¨¡å¼
  let isReading = false; // åˆå§‹è¨­ç½®ç‚ºæœªé–±è®€ç‹€æ…‹
  let audioPlayer = null;
          document.addEventListener('DOMContentLoaded', async () => {
    audioPlayer = document.getElementById('audioPlayer');
    
    // æª¢æŸ¥ API å¥åº·ç‹€æ…‹
    const isAPIHealthy = await checkAPIHealth();
    if (!isAPIHealthy) {
        console.warn('Edge TTS API æœå‹™æœªé‹è¡Œï¼ŒèªéŸ³åŠŸèƒ½å¯èƒ½ç„¡æ³•ä½¿ç”¨');
    }
    
    const findInput = document.getElementById('findInput'); // ç²å–è¼¸å…¥æ¬„ä½
    const findEntireWord = document.getElementById('findEntireWord'); // ç²å– Whole Words å‹¾é¸æ¡†
    let isFinding = false; // ç”¨æ–¼è¿½è¹¤æ˜¯å¦æœ‰æœªå®Œæˆçš„æŸ¥æ‰¾æ“ä½œ

    // å‡½æ•¸: ç™¼é€é¸ä¸­çš„æ–‡æœ¬åˆ°æ–°çš„ TTS API é€²è¡Œè™•ç†

        function getSheetIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('googlesheetid');
        }

        function fetchSheetData(sheetId) {
    const base = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?`;
    const query = encodeURIComponent('Select B, C format B "", C ""'); // ä½¿ç”¨ format å¼·åˆ¶è½‰æ›ç‚ºç´”æ–‡å­—
    const url = `${base}&tq=${query}`;

    return fetch(url)
        .then(res => res.text())
        .then(rep => {
            const jsonStr = rep.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/)[1];
            const data = JSON.parse(jsonStr);
            console.log("ç¢ºèªæ¬„ä½å°æ‡‰ï¼ˆç¬¬ä¸€è¡Œæ¨™é¡Œï¼Œå°‡è¢«è·³éï¼‰:", data.table.rows[0]?.c); // ç¬¬ä¸€è¡Œæ˜¯æ¨™é¡Œï¼Œå°‡å¾ç¬¬äºŒè¡Œé–‹å§‹å–å€¼
            return data;
        })
        .catch(err => {
            console.error('è¼‰å…¥å¤±æ•—:', err);
            return null;
        });
}

function replaceTextWithSheetData(text, data) {
    if (!data) return text;
    // å¾ç¬¬äºŒè¡Œé–‹å§‹å–å€¼ï¼ˆç¬¬ä¸€è¡Œæ˜¯æ¨™é¡Œï¼Œä½¿ç”¨ slice(1) è·³éï¼‰
    data.table.rows.slice(1).forEach(row => {
        // ç¢ºä¿è³‡æ–™å­˜åœ¨ä¸”è½‰æ›ç‚ºå­—ä¸²
        const original = row.c[0]?.v?.toString() || ''; // Bæ¬„ï¼ˆåŸå§‹æ–‡å­—ï¼‰
        const replacement = row.c[1]?.v?.toString() || ''; // Cæ¬„ï¼ˆæ›¿æ›æ–‡å­—ï¼‰
        if (original && replacement) {
            // ä½¿ç”¨å­—ä¸²æ›¿æ›ï¼Œç¢ºä¿éƒ½æ˜¯ç´”æ–‡å­—è™•ç†
            text = text.replace(new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g"), replacement);
        }
    });
    return text;
}

// å°‡ sendTextToTTS å®šç¾©åœ¨å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿å…¶ä»–å‡½æ•¸å¯ä»¥è¨ªå•
async function sendTextToTTS(selectedText, callback) {
    // åŠ å¼·æ–‡å­—æ¸…ç†ï¼Œç§»é™¤å¯èƒ½å°è‡´ SSML è§£æéŒ¯èª¤çš„ç‰¹æ®Šå­—ç¬¦
    const cleanedText = selectedText
        .replace(/[\r\n]+/g, ' ')
        .replace(/\s+/g, ' ')
        .replace(/[<>&]/g, '') // ç§»é™¤ SSML ç‰¹æ®Šå­—ç¬¦
        .trim();
    
    let filteredText = cleanedText; // Initialize with cleanedText as fallback
    
    const sheetId = getSheetIdFromUrl();
    if (sheetId) {
        const data = await fetchSheetData(sheetId);
        filteredText = replaceTextWithSheetData(cleanedText, data);
    }
    
    console.log("é€å‡ºçµ¦ TTS çš„æ–‡æœ¬:", filteredText);
    console.log("æ–‡æœ¬é•·åº¦:", filteredText.length);
    
    // æª¢æŸ¥æ–‡æœ¬æ˜¯å¦ç‚ºç©º
    if (!filteredText || filteredText.length === 0) {
        console.error('TTS æ–‡æœ¬ç‚ºç©ºï¼Œç„¡æ³•æœ—è®€');
        if (callback) callback();
        return;
    }
    
    // ç²å–é¸æ“‡çš„è²éŸ³å’Œèªé€Ÿ
    const voiceName = document.getElementById("voiceSelect").value;
    const rateValueRaw = parseFloat(document.getElementById('speakSpeed').value);
    const rateValue = Math.max(-50, Math.min(50, isNaN(rateValueRaw) ? 0 : rateValueRaw));
    const rateString = `${rateValue >= 0 ? '+' : ''}${rateValue}%`;

    // æ§‹å»º API è«‹æ±‚åƒæ•¸
    const requestData = {
        text: filteredText,
        voice: voiceName,
        rate: rateString,
        volume: "+0%",
        pitch: "+0Hz"
    };

    // ç™¼é€è«‹æ±‚åˆ° Edge TTS API
    fetch(`${API_CONFIG.BASE_URL}/tts`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
    })
    .then(response => {
        console.log('TTS API å›æ‡‰ç‹€æ…‹:', response.status);
        if (!response.ok) {
            throw new Error(`è«‹æ±‚å¤±æ•—ï¼š${response.status} ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('TTS API å›æ‡‰:', data);
        if (data.success) {
            // æˆåŠŸç”ŸæˆèªéŸ³ï¼Œç›´æ¥ä½¿ç”¨éŸ³é »URL
            const audioUrl = `${API_CONFIG.BASE_URL}${data.audio_url}`;
            console.log('éŸ³é »URL:', audioUrl);
            
            // è¨­ç½®éŸ³é »æ’­æ”¾å™¨
            const audioPlayer = document.getElementById('audioPlayer');
            
            // æ·»åŠ éŒ¯èª¤è™•ç†
            audioPlayer.onerror = (e) => {
                console.error('éŸ³é »è¼‰å…¥éŒ¯èª¤:', e);
                console.error('éŸ³é »å…ƒç´ éŒ¯èª¤:', audioPlayer.error);
                // è¼‰å…¥éŒ¯èª¤æ™‚èª¿ç”¨å›èª¿
                if (callback) callback();
            };
            
            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›£è½å™¨ï¼Œé˜²æ­¢é‡è¤‡æ’­æ”¾
            audioPlayer.oncanplay = null;
            audioPlayer.onended = null;
            audioPlayer.onerror = null;
            
            // è¨­ç½®è¼‰å…¥è¶…æ™‚
            let loadTimeout = setTimeout(() => {
                console.error('éŸ³é »è¼‰å…¥è¶…æ™‚');
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                    loadTimeout = null;
                }
                if (callback) callback();
            }, 10000); // 10ç§’è¶…æ™‚
            
            // æ·»åŠ è¼‰å…¥äº‹ä»¶ï¼ˆåªè¨­ç½®ä¸€æ¬¡ï¼‰
            audioPlayer.onloadstart = () => console.log('é–‹å§‹è¼‰å…¥éŸ³é »...');
            audioPlayer.oncanplay = () => {
                // æ¸…é™¤è¶…æ™‚
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                    loadTimeout = null;
                }
                
                console.log('éŸ³é »å¯ä»¥æ’­æ”¾');
                // éŸ³é »æº–å‚™å¥½å¾Œè‡ªå‹•æ’­æ”¾
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('éŸ³é »æ’­æ”¾æˆåŠŸ');
                            // æ’­æ”¾æˆåŠŸå¾Œè¨­ç½®å®Œæˆå›èª¿
                            audioPlayer.onended = callback;
                        })
                        .catch(error => {
                            console.error('éŸ³é »æ’­æ”¾å¤±æ•—:', error);
                            // æ’­æ”¾å¤±æ•—æ™‚ä¹Ÿè¦èª¿ç”¨å›èª¿
                            if (callback) callback();
                        });
                } else {
                    // å¦‚æœæ²’æœ‰æ’­æ”¾Promiseï¼Œç›´æ¥è¨­ç½®å›èª¿
                    audioPlayer.onended = callback;
                }
            };
            
            // æ·»åŠ æ›´å¤šäº‹ä»¶ç›£è½å™¨
            audioPlayer.onloadeddata = () => console.log('éŸ³é »æ•¸æ“šå·²è¼‰å…¥');
            audioPlayer.onprogress = () => console.log('éŸ³é »è¼‰å…¥é€²åº¦ä¸­...');
            audioPlayer.onabort = () => console.log('éŸ³é »è¼‰å…¥è¢«ä¸­æ­¢');
            audioPlayer.onstalled = () => console.log('éŸ³é »è¼‰å…¥åœæ»¯');
            audioPlayer.onsuspend = () => console.log('éŸ³é »è¼‰å…¥æš«åœ');
            
            // è¨­ç½®éŸ³é »æº
            audioPlayer.src = audioUrl;
        } else {
            throw new Error(data.error || 'èªéŸ³ç”Ÿæˆå¤±æ•—');
        }
    })
    .catch(error => {
        console.error('TTS ç™¼ç”ŸéŒ¯èª¤ï¼š', error);
        // ä¸è¦å½ˆå‡ºè­¦å‘Šï¼Œéœé»˜è™•ç†éŒ¯èª¤
        console.warn('TTS éŒ¯èª¤å·²è™•ç†ï¼Œç¹¼çºŒåŸ·è¡Œ');
        if (callback) callback();
    });
}

// å°‡ sendTextToTTS æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿å…¶ä»–å‡½æ•¸å¯ä»¥è¨ªå•
window.sendTextToTTS = sendTextToTTS;

        // createSSML å‡½æ•¸å·²ç§»é™¤ï¼Œç¾åœ¨ç›´æ¥ä½¿ç”¨ JSON æ ¼å¼ç™¼é€è«‹æ±‚

        const selectAllTextButton = document.getElementById('select-all-text');
        let sentences = [];
        let currentSentenceIndex = 0;
        let isReading = false;

        selectAllTextButton.addEventListener('click', function() {
            clearHighlights();
            if (isReading) {
                // å–æ¶ˆæœ—è®€
                cancelReading();
            } else {
                // é–‹å§‹æœ—è®€
                const pdfContainer = document.getElementById('pdfContainer');
                const textLayers = pdfContainer.getElementsByClassName('textLayer');
                let fullText = '';

                for (let textLayer of textLayers) {
                    const spans = textLayer.getElementsByTagName('span');
                    for (let span of spans) {
                        fullText += span.textContent + ' ';
                    }
                }

                const cleanedText = fullText.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
                sentences = cleanedText.split(/(?<=[ã€‚ï¼ï¼Ÿ])/); // æ ¹æ“šæ¨™é»ç¬¦è™Ÿåˆ†å¥
                currentSentenceIndex = 0;
                isReading = true;

                // ç«‹å³æ›´æ–°æŒ‰éˆ•æ¨£å¼å’Œæ–‡æœ¬
                selectAllTextButton.textContent = "å–æ¶ˆæœ—è®€";
                selectAllTextButton.classList.remove('button-light');
                selectAllTextButton.classList.add('button-danger');

                startReading(); // ç›´æ¥é–‹å§‹æœ—è®€
            }
        });

function cancelReading() {
  isReading = false;
  audioPlayer.pause();
  audioPlayer.currentTime = 0;
  selectAllTextButton.textContent = "æ•´é æœ—è®€";
  selectAllTextButton.classList.remove('button-danger');
  selectAllTextButton.classList.add('button-light');
  
  // æ¸…é™¤æ‰€æœ‰æ¨™ç¤º
  const textLayerDivs = document.querySelectorAll('#viewerContainer .textLayer my-fra');
  textLayerDivs.forEach(span => {
    span.style.backgroundColor = ''; // æ¸…é™¤æ¨™ç¤º
  });

  // æ¸…é™¤äº‹ä»¶ç›£è½å™¨
  audioPlayer.onended = null;
}

function startReading() {
    if (sentences.length > 0) {
        readNextSentence();
    } else {
        console.error('æ²’æœ‰å¯æœ—è®€çš„å¥å­');
    }
}

function readNextSentence() {
    if (isReading && currentSentenceIndex < sentences.length) {
        const sentence = sentences[currentSentenceIndex];
        highlightCurrentSentence(sentence);
        sendTextToTTS(sentence, function() {
            currentSentenceIndex++;
            if (currentSentenceIndex < sentences.length) {
                readNextSentence();
            } else {
                isReading = false;
                clearHighlights();
                selectAllTextButton.textContent = "æ•´é æœ—è®€";
                selectAllTextButton.classList.remove('button-danger');
                selectAllTextButton.classList.add('button-light');
            }
        });
    }
}

function highlightCurrentSentence(sentence) {
    const pdfContainer = document.getElementById('pdfContainer');
    const textLayers = pdfContainer.getElementsByClassName('textLayer');
    let spansArray = []; // å­˜å„²æ‰€æœ‰ <my-fra> æ¨™ç±¤

    // å°‡æ‰€æœ‰ <my-fra> æ¨™ç±¤å­˜å„²åˆ°æ•¸çµ„ä¸­ï¼Œä¸¦æŒ‰é †åºæ’åˆ—
    for (let textLayer of textLayers) {
        const spans = textLayer.getElementsByTagName('my-fra');
        for (let span of spans) {
            spansArray.push(span);
        }
    }

    // æ¸…é™¤å‰ä¸€å¥çš„æ¨™ç¤º
    for (let span of spansArray) {
        span.style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
    }

    // æŒ‰æ–·å¥ç¬¦è™Ÿåˆ†æ®µ
    const sentences = sentence.split(/([ã€‚ï¼ï¼Ÿ])/); // æ ¹æ“šå¥è™Ÿã€å•è™Ÿã€é©šå˜†è™Ÿåˆ†æ®µ
    const cleanedSentences = [];
    for (let i = 0; i < sentences.length; i += 2) {
        const sentenceText = sentences[i] + (sentences[i + 1] || ''); // å°‡æ–·å¥ç¬¦è™Ÿèˆ‡å¥å­åˆä½µ
        const cleanedSentence = sentenceText.replace(/\s+/g, ''); // å»é™¤ç©ºç™½å­—ç¬¦
        if (cleanedSentence) {
            cleanedSentences.push(cleanedSentence);
        }
    }

    // æŒ‰é †åºæ¨™ç¤ºæ¯å€‹å¥å­
    let currentIndex = 0; // ç•¶å‰éæ­·åˆ°çš„å­—ç¬¦ç´¢å¼•
    for (let s = 0; s < cleanedSentences.length; s++) {
        const cleanedSentence = cleanedSentences[s];
        let sentenceIndex = 0; // ç”¨æ–¼è¿½è¹¤ç•¶å‰å¥å­å­—ç¬¦ä½ç½®

        // å¾ç•¶å‰ç´¢å¼•é–‹å§‹ï¼Œå°‹æ‰¾åŒ¹é…çš„å­—ç¬¦
        while (currentIndex < spansArray.length && sentenceIndex < cleanedSentence.length) {
            const span = spansArray[currentIndex];
            const char = span.textContent.trim(); // å»é™¤å­—ç¬¦å‰å¾Œç©ºç™½

            // å¦‚æœå­—ç¬¦æ˜¯ç©ºç™½å­—ç¬¦ï¼Œå‰‡è·³é
            if (char === '') {
                currentIndex++;
                continue;
            }

            // å¦‚æœå­—ç¬¦åŒ¹é…
            if (char === cleanedSentence[sentenceIndex]) {
                span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // é«˜äº®é¡¯ç¤º
                sentenceIndex++;
            } else {
                // å¦‚æœå­—ç¬¦ä¸åŒ¹é…ï¼Œå‰‡æ¸…é™¤ç•¶å‰å¥å­çš„é«˜äº®
                for (let i = currentIndex - sentenceIndex; i < currentIndex; i++) {
                    spansArray[i].style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
                }
                sentenceIndex = 0; // é‡ç½®å¥å­ç´¢å¼•
            }

            currentIndex++; // ç§»å‹•åˆ°ä¸‹ä¸€å€‹å­—ç¬¦
        }

        // å¦‚æœå¥å­æ¨™ç¤ºå®Œæˆï¼Œå‰‡ç¹¼çºŒä¸‹ä¸€å€‹å¥å­
        if (sentenceIndex >= cleanedSentence.length) {
            console.log(`å¥å­ ${s + 1} æ¨™ç¤ºå®Œæˆ: ${cleanedSentence}`);
        } else {
            console.error(`å¥å­ ${s + 1} æ¨™ç¤ºå¤±æ•—: ${cleanedSentence}`);
        }
    }
}
// å¯ç§»å‹•æ¡†çš„åŠŸèƒ½
const frame = document.getElementById('movable-frame');
let isDragging = false;
let startX, startY;

// Add CSS styles for frame and resize buttons
const style = document.createElement('style');
style.innerHTML = `
  #movable-frame {
    position: absolute;
    width: 50px;
    height: 50px;
    border: 6px solid red;
    background-color: transparent;
    border-radius: 15px; /* Adjust the value to change the roundness */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */   
    z-index: 2000;
}
 .resize-button {
    position: absolute;
    width: 0;
    height: 0;
    cursor: pointer;
    z-index: 2000;
  } 
  #resize-bottom {
    width: 80px;
    height: 50px;
    background-color: orange;
    border-radius: 0 0 50px 50px; /* Bottom half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */   
    z-index: 2000;
  }
  #resize-right {
    width: 50px;
    height: 80px;
    background-color: orange;
    border-radius: 0 50px 50px 0; /* Right half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */
    white-space: pre-wrap; /* Allow text to wrap */   
    z-index: 2000;
  }
  #read-button {
    position: absolute;
    padding: 5px 10px;
    background-color: orange;
    color: blue;
    border: none;
    cursor: pointer;
    z-index: 2000;
    width: 90px;
    height: 40px;
    font-size:15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    border-top-left-radius: 15px; /* Top-left corner roundness */
    border-top-right-radius: 15px; /* Top-right corner roundness */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* Text shadow */    
  }
`;
document.head.appendChild(style);

// Add resize buttons
const buttons = [
  { direction: 'bottom' },
  { direction: 'right' }
];
buttons.forEach(({ direction }) => {
  const button = document.createElement('div');
  button.classList.add('resize-button');
  button.id = `resize-${direction}`;
  document.body.appendChild(button);
});

// Add read button
const readButton = document.createElement('button');
readButton.id = 'read-button';
readButton.textContent = 'æ¡†é¸æœ—è®€';
document.body.appendChild(readButton);

function initializeFramePosition() {
  const frame = document.getElementById('movable-frame');
  frame.style.top = `${frame.offsetTop + 90}px`; // å‘ä¸Šç§»å‹• 40px
  frame.style.left = `${frame.offsetLeft - 20}px`; // å‘ä¸Šç§»å‹• 40px
}

// æ›´æ–°æŒ‰éˆ•ä½ç½®
function updateButtonPositions() {
  const frame = document.getElementById('movable-frame');

  document.getElementById('resize-bottom').style.top = `${frame.offsetTop + frame.offsetHeight}px`;
  document.getElementById('resize-bottom').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 40}px`; // Adjusted for new width
  document.getElementById('resize-right').style.top = `${frame.offsetTop + frame.offsetHeight / 2 - 40}px`; // Adjusted for new height
  document.getElementById('resize-right').style.left = `${frame.offsetLeft + frame.offsetWidth}px`;
  document.getElementById('read-button').style.top = `${frame.offsetTop - 40}px`; // Position above the frame
  document.getElementById('read-button').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 45}px`; // Centered above the frame

  // Add text to the buttons
  document.getElementById('resize-bottom').textContent = 'â†•';
  document.getElementById('resize-right').textContent = 'â†”';

  // Center the text within the buttons
  document.getElementById('resize-bottom').style.display = 'flex';
  document.getElementById('resize-bottom').style.alignItems = 'center';
  document.getElementById('resize-bottom').style.justifyContent = 'center';
  
  document.getElementById('resize-right').style.display = 'flex';
  document.getElementById('resize-right').style.alignItems = 'center';
  document.getElementById('resize-right').style.justifyContent = 'center';
}

// åˆå§‹åŒ–æ¡†çš„ä½ç½®
initializeFramePosition();

frame.addEventListener('mousedown', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  startX = e.clientX - frame.offsetLeft;
  startY = e.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('mousemove', (e) => {
  if (isDragging) {
    frame.style.left = `${e.clientX - startX}px`;
    frame.style.top = `${e.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('mouseup', () => {
  isDragging = false;
});

frame.addEventListener('touchstart', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  const touch = e.touches[0];
  startX = touch.clientX - frame.offsetLeft;
  startY = touch.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('touchmove', (e) => {
  if (isDragging) {
    const touch = e.touches[0];
    frame.style.left = `${touch.clientX - startX}px`;
    frame.style.top = `${touch.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('touchend', () => {
  isDragging = false;
});

// Read button click event
readButton.addEventListener('click', readTextInsideFrame);

updateButtonPositions();
 

// åˆ¤æ–· canvas æ˜¯å¦ç‚ºå…¨ç™½
function isCanvasAllWhite(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    for (let i = 0; i < imageData.length; i += 4) {
        if (!(imageData[i] === 255 && imageData[i+1] === 255 && imageData[i+2] === 255 && imageData[i+3] === 255)) {
            return false;
        }
    }
    return true;
}

// è¼”åŠ©å‡½æ•¸ï¼šcanvas è½‰ base64ï¼Œä¾› Gemini åœ–ç‰‡è¾¨è­˜ç”¨
function canvasToBase64(canvas) {
    return canvas.toDataURL("image/png").split(',')[1];
}

// è¼”åŠ©å‡½æ•¸ï¼šGemini åœ–ç‰‡è¾¨è­˜
async function geminiImageDescribe(base64Image) {
    try {
        // å¾ IndexedDB è®€å– API KEYï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨é è¨­å€¼
        let apiKey = await loadApiKeyFromIndexedDB();
        if (!apiKey) {
            apiKey = ''; // é è¨­ API KEY
        }
        
        console.log('é–‹å§‹èª¿ç”¨ Gemini APIï¼ŒAPI KEY é•·åº¦:', apiKey.length);
        
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + apiKey, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: "ä½ æ˜¯ä¸€å€‹çµ¦å­¸ç¿’éšœç¤™å­¸ç”Ÿå ±è®€è€ƒé¡Œçš„å ±è®€å“¡ï¼Œä¸è¦ç”¢ç”Ÿ markdown çš„ * ç¬¦è™Ÿï¼Œè«‹å…ˆè®€å‡ºåœ–ç‰‡ä¸­çš„æ‰€æœ‰æ–‡å­—ï¼Œé‡åˆ°ç§‘å­¸æˆ–æ•¸å­¸ç¬¦è™Ÿè«‹è½‰æˆä¸­æ–‡æ–‡å­—çš„è®€æ³•ï¼Œé‡åˆ°æ•¸å­¸åˆ†æ•¸æ™‚ä»¥ä¸­æ–‡è®€æ³•è¡¨ç¤ºï¼Œå¦‚:å¹¾åˆ†ä¹‹å¹¾ï¼Œæ•¸å­¸å¼å­ç„¡é ˆå†ç‰¹åˆ¥èªªæ˜å®ƒæ˜¯ä¸€å€‹å…¬å¼ï¼Œå¦‚æœé€™äº›æ–‡å­—èˆ‡åœ–ç‰‡å…§å®¹æœ‰é—œï¼Œè«‹åˆä½µæè¿°ã€‚ç„¶å¾Œç”¨ç°¡å–®å¥å­æè¿°åœ–ç‰‡ä¸­çš„ç‰©ä»¶ï¼Œä¸è¦è´…è¿°ï¼Œä¸è¦æè¿°å ´æ™¯ã€æ•´é«”ä½ˆå±€æˆ–é¢¨æ ¼ï¼Œå¦‚æœæ–‡å­—éƒ¨åˆ†å·²èƒ½å‘ˆç¾å…¨éƒ¨ï¼Œæè¿°å®Œä¸è¦å†é‡è¤‡é™³è¿°åœ–ç‰‡å…ƒç´ ï¼Œå¦‚:å¼Ÿå¼Ÿåƒäº†å…«åˆ†ä¹‹äº”ç›’é›å¡Šï¼Œåœ–ç‰‡ä¸­ï¼Œé¡¯ç¤ºäº†ä¸€è¡Œä¸­æ–‡å­—å’Œä¸€å€‹åˆ†æ•¸ï¼Œåœ–ç‰‡ä¸­......ä»¥å¾Œå°±æ˜¯è´…è¿°ã€‚é‡åˆ°è‹±æ–‡å­—è«‹å¦‚å¯¦å‘ˆç¾ï¼Œä¸è¦æŠŠXè®€æˆè‰¾å…‹æ–¯ã€‚" },
                            { inline_data: { mime_type: "image/png", data: base64Image } }
                        ]
                    }
                ]
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Gemini API å›æ‡‰éŒ¯èª¤:', response.status, errorText);
            throw new Error(`API è«‹æ±‚å¤±æ•— (${response.status}): ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Gemini API å›æ‡‰:', data);
        
        if (data.error) {
            console.error('Gemini API éŒ¯èª¤:', data.error);
            throw new Error(data.error.message || 'API è¿”å›éŒ¯èª¤');
        }
        
        if (data.candidates && data.candidates.length > 0) {
            const text = data.candidates[0].content.parts[0].text;
            console.log('è¾¨è­˜çµæœ:', text);
            return text;
        } else {
            throw new Error('API å›æ‡‰ä¸­æ²’æœ‰è¾¨è­˜çµæœ');
        }
    } catch (error) {
        console.error('Gemini åœ–ç‰‡è¾¨è­˜éŒ¯èª¤:', error);
        throw error; // é‡æ–°æ‹‹å‡ºéŒ¯èª¤ï¼Œè®“èª¿ç”¨è€…è™•ç†
    }
}

async function readTextInsideFrame() {
    // å¦‚æœæ­£åœ¨é€²è¡Œåœ–ç‰‡è¾¨è­˜ï¼Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
    if (isImageRecognizing) {
        console.log('åœ–ç‰‡è¾¨è­˜æ­£åœ¨é€²è¡Œä¸­ï¼Œå¿½ç•¥é‡è¤‡è«‹æ±‚');
        return;
    }
    
    window.speechSynthesis.cancel();
    const frameRect = frame.getBoundingClientRect();
    const viewerContainer = document.getElementById('viewerContainer');
    const pdfCanvas = viewerContainer.querySelector('canvas');

    // å…ˆæŠ“ PDF æ–‡å­—å±¤
    const textLayerDivs = viewerContainer.getElementsByClassName('textLayer');
    let textInsideFrame = '';
    for (let textLayer of textLayerDivs) {
        const spans = textLayer.getElementsByTagName('my-fra');
        for (let span of spans) {
            const spanRect = span.getBoundingClientRect();
            if (isInsideFrame(spanRect, frameRect)) {
                span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
                textInsideFrame += span.textContent + '';
            }
        }
    }
    const cleanedText = textInsideFrame.trim().replace(/[\r\n]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
    // å–å¾—åœ–ç‰‡ base64
    let base64Image = null;
    let croppedCanvas = null;
    if (pdfCanvas) {
        croppedCanvas = cropCanvas(pdfCanvas, frameRect);
        base64Image = canvasToBase64(croppedCanvas);
    }
    // åˆ¤æ–·æ˜¯å¦æœ‰åœ–ç‰‡å…§å®¹
    let hasImageContent = false;
    if (croppedCanvas && !isCanvasAllWhite(croppedCanvas)) {
        hasImageContent = true;
    }
    // åˆ¤æ–·å…§å®¹
    if (!hasImageContent && cleanedText.length === 0) {
        Swal.fire({
            icon: 'warning',
            title: 'æ²’æœ‰å…§å®¹',
            text: 'æ¡†é¸å€åŸŸå…§æ²’æœ‰æ–‡å­—æˆ–åœ–ç‰‡'
        });
        return;
    }
    // åªè¦æœ‰ PDF æ–‡å­—å±¤ï¼Œå°±åªæœ—è®€ç´”æ–‡å­—ï¼Œä¸é€åœ–ç‰‡çµ¦ AI
    if (cleanedText.length > 0) {
        await new Promise((resolve, reject) => {
            sendTextToTTS(cleanedText, () => {
                resolve();
            });
        });
        return;
    }
    // æ²’æœ‰ PDF æ–‡å­—å±¤ï¼Œæ‰é€åœ–ç‰‡çµ¦ AI
    if (hasImageContent) {
        // è¨­ç½®æ¨™è¨˜ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
        isImageRecognizing = true;
        
        // åœ¨ iOS ä¸Šï¼Œéœ€è¦åœ¨ç”¨æˆ¶äº¤äº’çš„åŒæ­¥ä¸Šä¸‹æ–‡ä¸­ç«‹å³ç²å–éŸ³é »æ’­æ”¾æ¬Šé™
        // é€šéæ’­æ”¾"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚"ä¾†ç²å–æ¬Šé™ï¼ŒåŒæ™‚çµ¦ç”¨æˆ¶æç¤º
        // é˜²æ­¢é‡è¤‡æ’­æ”¾
        if (!isPlayingWaitingMessage) {
            isPlayingWaitingMessage = true;
            sendTextToTTS('åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚', () => {
                console.log('æ’­æ”¾æ¬Šé™å·²ç²å–ï¼Œé–‹å§‹åœ–ç‰‡è¾¨è­˜');
                isPlayingWaitingMessage = false; // æ’­æ”¾å®Œæˆå¾Œé‡ç½®æ¨™è¨˜
            });
        }
        
        try {
            Swal.fire({
                title: 'æ­£åœ¨è¾¨è­˜åœ–ç‰‡',
                text: 'æ­£åœ¨ä½¿ç”¨ AI è¾¨è­˜åœ–ç‰‡å…§å®¹...ï¼ˆGeminiï¼‰',
                allowOutsideClick: false,
                customClass: {
                    popup: 'swal-high-z-index'
                },
                didOpen: () => {
                    Swal.showLoading();
                }
            });
            const aiDescription = await geminiImageDescribe(base64Image);
            Swal.close();
            //console.log('Gemini åŸå§‹å›å‚³:', aiDescription);
            if (aiDescription && aiDescription.length > 0) {
                // ç­‰å¾…"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚"æ’­æ”¾å®Œæˆï¼ˆæˆ–è‡³å°‘ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿æ¬Šé™å·²ç²å–ï¼‰
                // å¦‚æœé‚„åœ¨æ’­æ”¾ï¼Œåœæ­¢å®ƒ
                const audioPlayer = document.getElementById('audioPlayer');
                if (audioPlayer && !audioPlayer.paused) {
                    audioPlayer.pause();
                    audioPlayer.currentTime = 0;
                }
                
                // ç›´æ¥ä½¿ç”¨ Gemini åŸå§‹å›å‚³ï¼Œä¸é€²è¡Œä»»ä½•æ¸…ç†
                // æ­¤æ™‚å·²ç¶“ç²å–äº†æ’­æ”¾æ¬Šé™ï¼Œå¯ä»¥è‡ªå‹•æ’­æ”¾
                sendTextToTTS(aiDescription, () => {
                    console.log('åœ–ç‰‡è¾¨è­˜æ–‡å­—æœ—è®€å®Œæˆ');
                    // è¾¨è­˜å®Œæˆï¼Œé‡ç½®æ¨™è¨˜
                    isImageRecognizing = false;
                    isPlayingWaitingMessage = false;
                });
            } else {
                console.error('Gemini å›å‚³çš„å…§å®¹ç‚ºç©º');
                Swal.fire({
                    icon: 'warning',
                    title: 'è¾¨è­˜çµæœç‚ºç©º',
                    text: 'AI ç„¡æ³•è¾¨è­˜åœ–ç‰‡å…§å®¹'
                });
                // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
                isImageRecognizing = false;
                isPlayingWaitingMessage = false;
            }
        } catch (error) {
            console.error('Gemini è¾¨è­˜å¤±æ•—:', error);
            Swal.fire({
                icon: 'error',
                title: 'è¾¨è­˜å¤±æ•—',
                text: 'AI è¾¨è­˜éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ã€‚'
            });
            // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
            isImageRecognizing = false;
            isPlayingWaitingMessage = false;
        }
        return;
    }
}

// è¼”åŠ©å‡½æ•¸ï¼šåˆ¤æ–·å…ƒç´ æ˜¯å¦åœ¨æ¡†é¸å€åŸŸå…§
function isInsideFrame(elementRect, frameRect) {
  return (
    elementRect.top >= frameRect.top &&
    elementRect.bottom <= frameRect.bottom &&
    elementRect.left >= frameRect.left &&
    elementRect.right <= frameRect.right
  );
}

// è¼”åŠ©å‡½æ•¸ï¼šè£å‰ªCanvaså€åŸŸ
function cropCanvas(sourceCanvas, cropRect) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // è€ƒæ…®è¨­å‚™åƒç´ æ¯”é€²è¡Œç²¾ç¢ºè£å‰ª
  const dpr = window.devicePixelRatio || 1;
  const cropX = (cropRect.left - sourceCanvas.getBoundingClientRect().left) * dpr;
  const cropY = (cropRect.top - sourceCanvas.getBoundingClientRect().top) * dpr;
  const cropWidth = cropRect.width * dpr;
  const cropHeight = cropRect.height * dpr;
  
  // è¨­ç½®æ–°Canvaså°ºå¯¸
  canvas.width = cropWidth;
  canvas.height = cropHeight;
  
  // åŸ·è¡Œè£å‰ªæ“ä½œ
  ctx.drawImage(
    sourceCanvas,
    cropX, cropY, cropWidth, cropHeight,
    0, 0, cropWidth, cropHeight
  );
  
  return canvas;
}

// ç¢ºä¿è¼”åŠ©å‡½æ•¸åœ¨å…¨å±€ä½œç”¨åŸŸå¯ç”¨
if (typeof window !== 'undefined') {
    window.cropCanvas = cropCanvas;
    window.canvasToBase64 = canvasToBase64;
    window.isCanvasAllWhite = isCanvasAllWhite;
    window.geminiImageDescribe = geminiImageDescribe;
}

  let lastTouchElement = null;
  let isImageRecognizing = false; // é˜²æ­¢åœ–ç‰‡è¾¨è­˜é‡è¤‡åŸ·è¡Œ
  let isPlayingWaitingMessage = false; // é˜²æ­¢"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™"èªéŸ³é‡è¤‡æ’­æ”¾

 function wrapTextInFraTags() {
    const markedContentSpans = document.querySelectorAll('span[role="presentation"]');
    
    markedContentSpans.forEach(span => {
        if (!span.dataset.processed) {
            const text = span.textContent;
            const fragment = document.createDocumentFragment();
            
            for (let char of text) {
                const fra = document.createElement('my-fra');
                fra.textContent = char;
                fra.style.cursor = 'pointer'; // å…§è¯æ¨£å¼
                fra.addEventListener('touchstart', highlightText);
                fra.addEventListener('touchmove', highlightText);
                fra.addEventListener('mousedown', startHighlight); // æ–°å¢æ»‘é¼ äº‹ä»¶
                fra.addEventListener('mousemove', highlightText); // æ–°å¢æ»‘é¼ äº‹ä»¶
                fragment.appendChild(fra);
            }
            
            span.innerHTML = '';
            span.appendChild(fragment);
            span.dataset.processed = 'true';
        }
    });
}
let isMouseDown = false;

function startHighlight(event) {
    isMouseDown = true;
    highlightText(event);
}

document.addEventListener('mouseup', () => {
    isMouseDown = false;
});
     function highlightText(event) {
     
    if (!document.getElementById('touchSelectCheckbox').checked) return; // æª¢æŸ¥æ ¸å–æ–¹å¡Šæ˜¯å¦è¢«é¸ä¸­
    if (event.type === 'mousemove' && !isMouseDown) return; // åªæœ‰åœ¨æŒ‰ä½æ»‘é¼ å·¦éµæ™‚æ‰è§¸ç™¼
    
   event.preventDefault(); // é˜²æ­¢å¹³æ¿å·¦å³æˆ–ä¸Šä¸‹æ²å‹•
    
    let element;
    if (event.type === 'touchstart' || event.type === 'touchmove') {
        const touch = event.touches[0];
        element = document.elementFromPoint(touch.clientX, touch.clientY);
    } else if (event.type === 'mousedown' || event.type === 'mousemove') {
        element = event.target;
    }
    
    if (element && element.tagName === 'MY-FRA') {
        if (element !== lastTouchElement) {
            if (element.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                element.style.backgroundColor = ''; // å–æ¶ˆé¸å–
            } else if (element.style.backgroundColor === 'rgba(255, 255, 0, 0.2)') {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // é‡æ–°é¸å–
                element.dataset.spoken = ''; // å–æ¶ˆå·²ç™¼éŸ³æ¨™è¨˜
            } else {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // æ”¹è®ŠèƒŒæ™¯é¡è‰²
            }
            lastTouchElement = element;
        }
    }
}
        function sendHighlightedText() {
            const highlightedText = [];
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                    if (span.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                        highlightedText.push(span.textContent);
                        span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // å·²ç™¼éŸ³çš„æ¨™ç¤º
                        span.dataset.spoken = 'true'; // æ¨™è¨˜ç‚ºå·²ç™¼éŸ³
                    }
                }
            }
            
            const cleanedText = highlightedText.join('').replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
            sendTextToTTS(cleanedText, () => {
                // æœ—è®€å®Œæˆå¾Œçš„å›èª¿
                document.getElementById('sendButton').textContent = "æœ—è®€é¸å–æ–‡å­—";
                document.getElementById('sendButton').classList.remove('button-danger');
                document.getElementById('sendButton').classList.add('button-light');
                isReading = false;
            });
        }

        function clearHighlights() {
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                window.speechSynthesis.cancel();
                    span.style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
                    span.dataset.spoken = ''; // æ¸…é™¤å·²ç™¼éŸ³æ¨™è¨˜
                }
            }
        }

        document.getElementById('sendButton').addEventListener('click', sendHighlightedText);
        document.getElementById('clearButton').addEventListener('click', clearHighlights);
        document.getElementById('touchSelectCheckbox').addEventListener('change', function() {
            const isChecked = this.checked;
            clearHighlights();            
            document.getElementById('sendButton').style.display = isChecked ? 'block' : 'none';
            document.getElementById('clearButton').style.display = isChecked ? 'block' : 'none';                        
            document.getElementById('select-all-text').style.display = isChecked ? 'none' : 'block';            
            document.getElementById('movable-frame').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-bottom').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-right').style.display = isChecked ? 'none' : 'block';
            document.getElementById('read-button').style.display = isChecked ? 'none' : 'block';
            
            if (!isChecked) {
            updateButtonPositions();            
            }
        });
        wrapTextInFraTags();
        
        document.getElementById('sendButton').addEventListener('click', function() {
    if (isReading) {
        // å–æ¶ˆæœ—è®€
        window.speechSynthesis.cancel();
        this.textContent = "æœ—è®€é¸å–æ–‡å­—";
        this.classList.remove('button-danger');
        this.classList.add('button-light');
        isReading = false;
    } else {
        // é–‹å§‹æœ—è®€
        sendHighlightedText();
        this.textContent = "å–æ¶ˆæœ—è®€";
        this.classList.remove('button-light');
        this.classList.add('button-danger');
        isReading = true;
    }
});
  
// ä½¿ç”¨ MutationObserver ç›£è½ DOM è®ŠåŒ–
const observer = new MutationObserver((mutationsList, observer) => {
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            wrapTextInFraTags();
        }
    }
});

// é…ç½® MutationObserver ç›£è½çš„ç›®æ¨™ç¯€é»å’Œé¸é …
const config = { childList: true, subtree: true };

// ç›£è½æ•´å€‹ document çš„è®ŠåŒ–
observer.observe(document, config);

// ç¢ºä¿åœ¨ DOM å®Œå…¨åŠ è¼‰å¾ŒåŸ·è¡Œ
document.addEventListener('DOMContentLoaded', wrapTextInFraTags);
document.getElementById('resize-bottom').addEventListener('mousedown', (e) => resizeFrame(e, 'bottom'));
document.getElementById('resize-right').addEventListener('mousedown', (e) => resizeFrame(e, 'right'));

document.getElementById('resize-bottom').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'bottom'));
document.getElementById('resize-right').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'right'));

function resizeFrame(e, direction) {
  e.stopPropagation();
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  let startX = e.clientX;
  let startY = e.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    if (direction === 'bottom') {
      let newHeight = startHeight + (e.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (e.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('mousemove', doDrag);
    document.removeEventListener('mouseup', stopDrag);
  }

  document.addEventListener('mousemove', doDrag);
  document.addEventListener('mouseup', stopDrag);
}

function resizeFrameTouch(e, direction) {
  e.stopPropagation();
  e.preventDefault(); // Prevent scrolling
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  const touch = e.touches[0];
  let startX = touch.clientX;
  let startY = touch.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    const touch = e.touches[0];
    if (direction === 'bottom') {
      let newHeight = startHeight + (touch.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (touch.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('touchmove', doDrag);
    document.removeEventListener('touchend', stopDrag);
  }

  document.addEventListener('touchmove', doDrag);
  document.addEventListener('touchend', stopDrag);
}

updateButtonPositions();
});
// ç²å–æ¡†å…ƒç´ 
const frame = document.getElementById('movable-frame');

function showPage(page_no) {
    __PAGE_RENDERING_IN_PROGRESS = 1;
    __CURRENT_PAGE = page_no;
    $("#pdf-next, #pdf-prev").attr('disabled', 'disabled');
    $("#pdf-canvas").hide();
    $("#page-loader").show();
    $("#pdf-current-page").text(page_no);
    __PDF_DOC.getPage(page_no).then(function (page) {
        let viewport = page.getViewport({ scale: 1 });
        let scale = __CANVAS.width / viewport.width;
        viewport = page.getViewport({ scale: scale });
        __CANVAS.height = viewport.height;
        var renderContext = {
            canvasContext: __CANVAS_CTX,
            viewport: viewport
        };
        page.render(renderContext).promise.then(function () {
            __PAGE_RENDERING_IN_PROGRESS = 0;
            $("#pdf-next, #pdf-prev").removeAttr('disabled');
            $("#pdf-canvas").show();
            $("#page-loader").hide();
            return page.getTextContent();
        }).then(function (textContent) {
            var canvas_offset = $("#pdf-canvas").offset();
            $("#text-layer").html('');
            document.getElementById('text-layer').style.setProperty('--scale-factor', viewport.scale);
            $("#text-layer").css({ left: canvas_offset.left + 'px', top: canvas_offset.top + 'px' });
            PDFJS.renderTextLayer({
                textContentSource: textContent,
                container: $("#text-layer").get(0),
                viewport: viewport,
                textDivs: []
            });
            console.log('Text Layer Content:', textContent);
        });
    });
}




     // æ›´æ–°èªé€Ÿé¡¯ç¤º
function updateRate(value) {
    const adjustedValue = Math.max(-50, Math.min(50, Number(value)));
    const speedLabel = document.getElementById('speedLabel');
    const speedPercent = document.getElementById('speedPercent');
    
    if (adjustedValue === 0) {
        speedLabel.textContent = '';
        speedPercent.textContent = '0%';
    } else if (adjustedValue > 0) {
        speedLabel.textContent = 'èªé€ŸåŠ ';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    } else {
        speedLabel.textContent = 'èªé€Ÿæ¸›';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    }
}

// è¨­ç½®åˆå§‹èªé€Ÿ
document.getElementById('speakSpeed').value = -30;
updateRate(-30);

// API KEY ç®¡ç†åŠŸèƒ½
let qrStream = null;
let qrScanInterval = null;

// æ‰“é–‹ API KEY è¨­å®šæ¨¡æ…‹è¦–çª—
document.getElementById('apiKeySettingsButton').addEventListener('click', async () => {
    const modal = document.getElementById('apiKeyModal');
    const overlay = document.getElementById('apiKeyModalOverlay');
    const apiKeyInput = document.getElementById('apiKeyInput');
    
    // è¼‰å…¥ç¾æœ‰çš„ API KEYï¼ˆä¸é¡¯ç¤ºå®Œæ•´ï¼Œåªé¡¯ç¤ºå‰å¾Œå¹¾ä½ï¼‰
    const existingKey = await loadApiKeyFromIndexedDB();
    if (existingKey) {
        const maskedKey = existingKey.length > 8 
            ? existingKey.substring(0, 4) + '...' + existingKey.substring(existingKey.length - 4)
            : '***';
        apiKeyInput.placeholder = `å·²è¨­å®šï¼š${maskedKey}`;
    } else {
        apiKeyInput.placeholder = 'è«‹è¼¸å…¥æˆ–æƒæ QR Code';
    }
    apiKeyInput.value = '';
    
    modal.style.display = 'block';
    overlay.style.display = 'block';
});

// é—œé–‰æ¨¡æ…‹è¦–çª—
function closeApiKeyModal() {
    const modal = document.getElementById('apiKeyModal');
    const overlay = document.getElementById('apiKeyModalOverlay');
    const qrContainer = document.getElementById('qrScannerContainer');
    
    modal.style.display = 'none';
    overlay.style.display = 'none';
    qrContainer.style.display = 'none';
    
    // åœæ­¢ QR code æƒæ
    stopQRScan();
}

document.getElementById('cancelApiKeyButton').addEventListener('click', closeApiKeyModal);
document.getElementById('apiKeyModalOverlay').addEventListener('click', closeApiKeyModal);

// å„²å­˜ API KEY
document.getElementById('saveApiKeyButton').addEventListener('click', async () => {
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKey = apiKeyInput.value.trim();
    
    if (!apiKey) {
        Swal.fire({
            icon: 'warning',
            title: 'è¼¸å…¥ç‚ºç©º',
            text: 'è«‹è¼¸å…¥ API KEY æˆ–æƒæ QR Code'
        });
        return;
    }
    
    try {
        await saveApiKeyToIndexedDB(apiKey);
        Swal.fire({
            icon: 'success',
            title: 'å„²å­˜æˆåŠŸ',
            text: 'API KEY å·²å„²å­˜',
            timer: 1500,
            showConfirmButton: false
        });
        closeApiKeyModal();
    } catch (error) {
        console.error('å„²å­˜ API KEY å¤±æ•—ï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'å„²å­˜å¤±æ•—',
            text: 'ç„¡æ³•å„²å­˜ API KEYï¼Œè«‹é‡è©¦'
        });
    }
});

// åˆªé™¤ API KEY
document.getElementById('deleteApiKeyButton').addEventListener('click', async () => {
    // ç¢ºèªåˆªé™¤
    const result = await Swal.fire({
        icon: 'warning',
        title: 'ç¢ºèªåˆªé™¤',
        text: 'ç¢ºå®šè¦åˆªé™¤ç¾æœ‰çš„ API KEY å—ï¼Ÿ',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®šåˆªé™¤',
        cancelButtonText: 'å–æ¶ˆ',
        confirmButtonColor: '#dc3545',
        cancelButtonColor: '#6c757d',
        customClass: {
            popup: 'swal-high-z-index',
            container: 'swal-high-z-index'
        }
    });
    
    if (result.isConfirmed) {
        try {
            await deleteApiKeyFromIndexedDB();
            // æ¸…ç©ºè¼¸å…¥æ¡†å’Œæç¤º
            document.getElementById('apiKeyInput').value = '';
            document.getElementById('apiKeyInput').placeholder = 'è«‹è¼¸å…¥æˆ–æƒæ QR Code';
            
            Swal.fire({
                icon: 'success',
                title: 'åˆªé™¤æˆåŠŸ',
                text: 'API KEY å·²åˆªé™¤',
                timer: 1500,
                showConfirmButton: false,
                customClass: {
                    popup: 'swal-high-z-index',
                    container: 'swal-high-z-index'
                }
            });
            closeApiKeyModal();
        } catch (error) {
            console.error('åˆªé™¤ API KEY å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'åˆªé™¤å¤±æ•—',
                text: 'ç„¡æ³•åˆªé™¤ API KEYï¼Œè«‹é‡è©¦',
                customClass: {
                    popup: 'swal-high-z-index',
                    container: 'swal-high-z-index'
                }
            });
        }
    }
});

// åœæ­¢ QR code æƒæ
function stopQRScan() {
    if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
    }
    if (qrScanInterval) {
        clearInterval(qrScanInterval);
        qrScanInterval = null;
    }
    const qrVideo = document.getElementById('qrVideo');
    const qrContainer = document.getElementById('qrScannerContainer');
    qrVideo.srcObject = null;
    qrContainer.style.display = 'none';
}

// é–‹å§‹ QR code æƒæ
document.getElementById('scanQRButton').addEventListener('click', async () => {
    const qrContainer = document.getElementById('qrScannerContainer');
    const qrVideo = document.getElementById('qrVideo');
    const qrCanvas = document.getElementById('qrCanvas');
    
    try {
        // è«‹æ±‚ç›¸æ©Ÿæ¬Šé™
        qrStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: 'environment' // å„ªå…ˆä½¿ç”¨å¾Œç½®ç›¸æ©Ÿ
            } 
        });
        
        qrVideo.srcObject = qrStream;
        qrVideo.setAttribute('playsinline', true);
        qrContainer.style.display = 'block';
        
        await qrVideo.play();
        
        const videoWidth = qrVideo.videoWidth;
        const videoHeight = qrVideo.videoHeight;
        qrCanvas.width = videoWidth;
        qrCanvas.height = videoHeight;
        
        const ctx = qrCanvas.getContext('2d');
        
        // é–‹å§‹æƒæ
        qrScanInterval = setInterval(() => {
            if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
                ctx.drawImage(qrVideo, 0, 0, videoWidth, videoHeight);
                const imageData = ctx.getImageData(0, 0, videoWidth, videoHeight);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                
                if (code) {
                    // æ‰¾åˆ° QR codeï¼Œå¡«å…¥ API KEY
                    document.getElementById('apiKeyInput').value = code.data;
                    stopQRScan();
                    Swal.fire({
                        icon: 'success',
                        title: 'æƒææˆåŠŸ',
                        text: 'QR Code å·²è®€å–',
                        timer: 1500,
                        showConfirmButton: false
                    });
                }
            }
        }, 100);
        
    } catch (error) {
        console.error('ç„¡æ³•è¨ªå•ç›¸æ©Ÿï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'ç„¡æ³•è¨ªå•ç›¸æ©Ÿ',
            text: 'è«‹å…è¨±ç€è¦½å™¨è¨ªå•ç›¸æ©Ÿæ¬Šé™ï¼Œæˆ–æ‰‹å‹•è¼¸å…¥ API KEY'
        });
    }
});

// åœæ­¢æƒææŒ‰éˆ•
document.getElementById('stopScanButton').addEventListener('click', stopQRScan);

// ========== å€å¡Šæ¨™è¨˜åŠŸèƒ½ ==========
let isMarkingMode = false;
let currentMark = null;
let marks = {}; // å­˜å„²æ‰€æœ‰æ¨™è¨˜ {pageNum: [{id, x, y, width, height, text}]}
let markIdCounter = 0;
let originalPdfBytes = null; // ä¿å­˜åŸå§‹PDFå­—ç¯€

// åˆå§‹åŒ–æ¨™è¨˜åŠŸèƒ½
function initMarkingFeature() {
    // æ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•
    const markButton = document.getElementById('markBlockButton');
    const saveButton = document.getElementById('saveMarkedPdfButton');
    const downloadButton = document.getElementById('downloadMarkedPdfButton');
    const clearButton = document.getElementById('clearMarksButton');
    
    // å·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•
    const markButtonToolbar = document.getElementById('markBlockButtonToolbar');
    const saveButtonToolbar = document.getElementById('saveMarkedPdfButtonToolbar');
    const downloadButtonToolbar = document.getElementById('downloadMarkedPdfButtonToolbar');
    const clearButtonToolbar = document.getElementById('clearMarksButtonToolbar');
    
    // ç¶å®šæ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•äº‹ä»¶
    if (markButton) markButton.addEventListener('click', toggleMarkingMode);
    if (saveButton) saveButton.addEventListener('click', saveMarksToPdf);
    if (downloadButton) downloadButton.addEventListener('click', downloadMarkedPdf);
    if (clearButton) clearButton.addEventListener('click', clearAllMarks);
    
    // ç¶å®šå·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•äº‹ä»¶
    if (markButtonToolbar) markButtonToolbar.addEventListener('click', toggleMarkingMode);
    if (saveButtonToolbar) saveButtonToolbar.addEventListener('click', saveMarksToPdf);
    if (downloadButtonToolbar) downloadButtonToolbar.addEventListener('click', downloadMarkedPdf);
    if (clearButtonToolbar) clearButtonToolbar.addEventListener('click', clearAllMarks);
    
    // è¼‰å…¥å·²ä¿å­˜çš„æ¨™è¨˜ï¼ˆå„ªå…ˆå¾PDFæ–‡ä»¶è¼‰å…¥ï¼‰
    loadMarksFromPdf();
}

// åˆ‡æ›æ¨™è¨˜æ¨¡å¼
function toggleMarkingMode() {
    isMarkingMode = !isMarkingMode;
    const markButton = document.getElementById('markBlockButton');
    const saveButton = document.getElementById('saveMarkedPdfButton');
    const downloadButton = document.getElementById('downloadMarkedPdfButton');
    const clearButton = document.getElementById('clearMarksButton');
    
    // å·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•
    const markButtonToolbar = document.getElementById('markBlockButtonToolbar');
    const saveButtonToolbar = document.getElementById('saveMarkedPdfButtonToolbar');
    const downloadButtonToolbar = document.getElementById('downloadMarkedPdfButtonToolbar');
    const clearButtonToolbar = document.getElementById('clearMarksButtonToolbar');
    const markingToolbar = document.getElementById('markingToolbar');
    
    const toggleButton = document.getElementById('toggleMarksButton');
    
    if (isMarkingMode) {
        // é—œé–‰API KEYæ¨¡æ…‹è¦–çª—ï¼ˆå¦‚æœæ‰“é–‹ï¼‰
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyModalOverlay = document.getElementById('apiKeyModalOverlay');
        if (apiKeyModal) apiKeyModal.style.display = 'none';
        if (apiKeyModalOverlay) apiKeyModalOverlay.style.display = 'none';
        
        // é¡¯ç¤ºæ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„ï¼ˆæ©«å‘ï¼Œç½®é ‚ï¼‰
        if (markingToolbar) {
            markingToolbar.classList.add('show');
        }
        
        // æ›´æ–°æ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•
        if (markButton) {
            markButton.textContent = 'å–æ¶ˆæ¨™è¨˜';
            markButton.classList.remove('button-success');
            markButton.classList.add('button-danger');
        }
        if (saveButton) saveButton.style.display = 'block';
        if (downloadButton) downloadButton.style.display = 'block';
        if (clearButton) clearButton.style.display = 'block';
        
        // æ›´æ–°å·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•
        if (markButtonToolbar) {
            markButtonToolbar.textContent = 'å–æ¶ˆæ¨™è¨˜';
            markButtonToolbar.classList.remove('button-success');
            markButtonToolbar.classList.add('button-danger');
        }
        if (saveButtonToolbar) saveButtonToolbar.style.display = 'inline-block';
        if (downloadButtonToolbar) downloadButtonToolbar.style.display = 'inline-block';
        if (clearButtonToolbar) clearButtonToolbar.style.display = 'inline-block';
        
        // ä¸é¡¯ç¤º toggleMarksButtonï¼Œå› ç‚ºåªæœ‰ç·¨è¼¯æ¨¡å¼æ‰é¡¯ç¤ºæ¨™è¨˜
        if (toggleButton) toggleButton.style.display = 'none';
        document.body.style.cursor = 'crosshair';
        
        // èª¿æ•´PDFå®¹å™¨é ‚éƒ¨é‚Šè·ï¼Œç‚ºå·¥å…·æ¬„ç•™å‡ºç©ºé–“
        const pdfContainer = document.getElementById('pdfContainer');
        if (pdfContainer) {
            pdfContainer.style.marginTop = '60px';
        }
        
        // å•Ÿç”¨æ¨™è¨˜å±¤çš„äº‹ä»¶å’Œé¡¯ç¤º
        const markLayers = document.querySelectorAll('.mark-layer');
        markLayers.forEach(layer => {
            layer.classList.add('marking-mode');
            layer.classList.remove('hidden'); // ç¢ºä¿æ¨™è¨˜å±¤å¯è¦‹
            layer.style.display = 'block';
            layer.style.visibility = 'visible';
        });
        
        // é‡æ–°æ¸²æŸ“æ¨™è¨˜ä»¥ç¢ºä¿æ‰€æœ‰æ¨™è¨˜éƒ½é¡¯ç¤ºï¼ˆç·¨è¼¯æ¨¡å¼ï¼‰
        renderMarks();
        
        // é¡¯ç¤ºæ‰€æœ‰æ¨™è¨˜å€å¡Šï¼ˆç·¨è¼¯æ¨¡å¼ï¼‰
        // ä½¿ç”¨ setTimeout ç¢ºä¿ renderMarks å®Œæˆå¾Œå†è¨­ç½®æ¨£å¼
        setTimeout(() => {
            const markBlocks = document.querySelectorAll('.mark-block');
            markBlocks.forEach(block => {
                block.style.display = 'block';
                block.style.visibility = 'visible';
                block.style.opacity = '1';
                // æ¢å¾©é‚Šæ¡†å’ŒèƒŒæ™¯è‰²
                block.style.border = '3px solid #007BFF';
                block.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
                // é¡¯ç¤ºæ¨™ç±¤å’Œåˆªé™¤æŒ‰éˆ•
                const label = block.querySelector('.mark-label');
                const deleteBtn = block.querySelector('.mark-delete');
                if (label) {
                    label.style.display = 'block';
                }
                if (deleteBtn) {
                    deleteBtn.style.display = 'flex';
                }
            });
        }, 100);
        
        // åœ¨ PDF viewer ä¸Šç¶å®šäº‹ä»¶
        const pdfViewers = document.querySelectorAll('.pdf-viewer');
        pdfViewers.forEach(viewer => {
            viewer.addEventListener('mousedown', handleViewerMouseDown);
            viewer.addEventListener('touchstart', handleViewerTouchStart);
        });
    } else {
        // éš±è—æ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„
        if (markingToolbar) {
            markingToolbar.classList.remove('show');
        }
        
        // æ¢å¾©PDFå®¹å™¨é ‚éƒ¨é‚Šè·
        const pdfContainer = document.getElementById('pdfContainer');
        if (pdfContainer) {
            pdfContainer.style.marginTop = '80px';
        }
        
        // æ›´æ–°æ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•
        if (markButton) {
            markButton.textContent = 'æ¨™è¨˜å€å¡Š';
            markButton.classList.remove('button-danger');
            markButton.classList.add('button-success');
        }
        if (saveButton) saveButton.style.display = 'none';
        if (downloadButton) downloadButton.style.display = 'none';
        if (clearButton) clearButton.style.display = 'none';
        
        // æ›´æ–°å·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•
        if (markButtonToolbar) {
            markButtonToolbar.textContent = 'æ¨™è¨˜å€å¡Š';
            markButtonToolbar.classList.remove('button-danger');
            markButtonToolbar.classList.add('button-success');
        }
        if (saveButtonToolbar) saveButtonToolbar.style.display = 'none';
        if (downloadButtonToolbar) downloadButtonToolbar.style.display = 'none';
        if (clearButtonToolbar) clearButtonToolbar.style.display = 'none';
        
        if (toggleButton) toggleButton.style.display = 'none';
        document.body.style.cursor = 'default';
        if (currentMark) {
            currentMark = null;
        }
        
        // ç¦ç”¨æ¨™è¨˜å±¤çš„äº‹ä»¶ï¼ˆä½†ä¿ç•™é»æ“Šæ¨™è¨˜å€å¡Šçš„åŠŸèƒ½ï¼‰
        const markLayers = document.querySelectorAll('.mark-layer');
        markLayers.forEach(layer => {
            layer.classList.remove('marking-mode');
        });
        
        // éš±è—æ‰€æœ‰æ¨™è¨˜å€å¡Šçš„è¦–è¦ºé¡¯ç¤ºï¼ˆä½†ä¿ç•™é»æ“ŠåŠŸèƒ½ï¼‰
        const markBlocks = document.querySelectorAll('.mark-block');
        markBlocks.forEach(block => {
            // éš±è—è¦–è¦ºé¡¯ç¤ºï¼Œä½†ä¿ç•™å…ƒç´ ä»¥ä¾¿é»æ“Š
            block.style.opacity = '0';
            block.style.pointerEvents = 'auto'; // ä¿ç•™é»æ“ŠåŠŸèƒ½
            block.style.backgroundColor = 'transparent'; // ç¢ºä¿èƒŒæ™¯é€æ˜
            block.style.border = 'none'; // éš±è—é‚Šæ¡†
            // éš±è—æ¨™ç±¤å’Œåˆªé™¤æŒ‰éˆ•
            const label = block.querySelector('.mark-label');
            const deleteBtn = block.querySelector('.mark-delete');
            if (label) label.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
        });
        
        // ç§»é™¤ PDF viewer ä¸Šçš„äº‹ä»¶ç›£è½å™¨
        const pdfViewers = document.querySelectorAll('.pdf-viewer');
        pdfViewers.forEach(viewer => {
            viewer.removeEventListener('mousedown', handleViewerMouseDown);
            viewer.removeEventListener('touchstart', handleViewerTouchStart);
        });
    }
}

// è™•ç† PDF viewer çš„æ»‘é¼ æŒ‰ä¸‹äº‹ä»¶
function handleViewerMouseDown(e) {
    if (!isMarkingMode || !pdfDoc) return;
    
    // å¦‚æœé»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šï¼Œä¸è™•ç†
    if (e.target.closest('.mark-block')) return;
    
    // å¦‚æœé»æ“Šçš„æ˜¯ canvas æˆ–æ¨™è¨˜å±¤ï¼Œé–‹å§‹æ¨™è¨˜
    if (e.target.tagName === 'CANVAS' || e.target.classList.contains('mark-layer') || e.target.classList.contains('pdf-viewer')) {
        startMarking(e);
    }
}

// è™•ç† PDF viewer çš„è§¸æ§é–‹å§‹äº‹ä»¶
function handleViewerTouchStart(e) {
    if (!isMarkingMode || !pdfDoc) return;
    
    // å¦‚æœé»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šï¼Œä¸è™•ç†
    if (e.target.closest('.mark-block')) return;
    
    // å¦‚æœé»æ“Šçš„æ˜¯ canvas æˆ–æ¨™è¨˜å±¤ï¼Œé–‹å§‹æ¨™è¨˜
    if (e.target.tagName === 'CANVAS' || e.target.classList.contains('mark-layer') || e.target.classList.contains('pdf-viewer')) {
        startMarking(e);
    }
}

// é–‹å§‹ç¹ªè£½æ¨™è¨˜
function startMarking(e) {
    if (!isMarkingMode || !pdfDoc) {
        console.log('æ¨™è¨˜æ¨¡å¼æœªå•Ÿç”¨æˆ–PDFæœªè¼‰å…¥, isMarkingMode:', isMarkingMode, 'pdfDoc:', !!pdfDoc);
        return;
    }
    
    // å¦‚æœé»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šæœ¬èº«ï¼Œä¸é–‹å§‹æ–°çš„æ¨™è¨˜
    if (e.target.classList.contains('mark-block') || 
        e.target.classList.contains('mark-delete') ||
        e.target.closest('.mark-block')) {
        return;
    }
    
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
    if (!markLayer) {
        console.warn('æ¨™è¨˜å±¤ä¸å­˜åœ¨ï¼Œé ç¢¼:', currentPage);
        return;
    }
    
    // ç¢ºä¿æ¨™è¨˜å±¤è™•æ–¼æ¨™è¨˜æ¨¡å¼
    if (!markLayer.classList.contains('marking-mode')) {
        markLayer.classList.add('marking-mode');
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    // ç²å–ç›¸å°æ–¼æ¨™è¨˜å±¤çš„ä½ç½®
    const rect = markLayer.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const startX = clientX - rect.left;
    const startY = clientY - rect.top;
    
    console.log('é–‹å§‹æ¨™è¨˜ï¼Œä½ç½®:', startX, startY, 'é ç¢¼:', currentPage, 'äº‹ä»¶ç›®æ¨™:', e.target);
    
    currentMark = {
        id: markIdCounter++,
        startX,
        startY,
        x: startX,
        y: startY,
        width: 0,
        height: 0,
        pageNum: currentPage
    };
    
    const markBlock = document.createElement('div');
    markBlock.className = 'mark-block';
    markBlock.dataset.markId = currentMark.id;
    markBlock.style.position = 'absolute';
    markBlock.style.left = `${startX}px`;
    markBlock.style.top = `${startY}px`;
    markBlock.style.width = '0px';
    markBlock.style.height = '0px';
    markBlock.style.display = 'block'; // ç¢ºä¿é¡¯ç¤º
    markBlock.style.visibility = 'visible'; // ç¢ºä¿å¯è¦‹
    markBlock.style.opacity = '1'; // ç¢ºä¿ä¸é€æ˜
    
    const label = document.createElement('div');
    label.className = 'mark-label';
    label.textContent = `å€å¡Š ${currentMark.id + 1}`;
    markBlock.appendChild(label);
    
    markLayer.appendChild(markBlock);
    currentMark.element = markBlock;
    
    console.log('æ¨™è¨˜æ¡†å·²å‰µå»ºï¼Œä½ç½®:', startX, startY, 'å…ƒç´ :', markBlock);
    
    // ä½¿ç”¨ capture æ¨¡å¼ç¢ºä¿äº‹ä»¶èƒ½æ­£ç¢ºæ•ç²
    document.addEventListener('mousemove', updateMark, true);
    document.addEventListener('mouseup', finishMark, true);
    document.addEventListener('touchmove', updateMark, true);
    document.addEventListener('touchend', finishMark, true);
    
    console.log('æ¨™è¨˜é–‹å§‹ï¼Œå·²æ·»åŠ äº‹ä»¶ç›£è½å™¨');
}

// æ›´æ–°æ¨™è¨˜å¤§å°
function updateMark(e) {
    if (!currentMark) return;
    
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
    if (!markLayer) return;
    
    const rect = markLayer.getBoundingClientRect();
    const currentX = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const currentY = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    
    const width = Math.abs(currentX - currentMark.startX);
    const height = Math.abs(currentY - currentMark.startY);
    const x = Math.min(currentMark.startX, currentX);
    const y = Math.min(currentMark.startY, currentY);
    
    currentMark.x = x;
    currentMark.y = y;
    currentMark.width = width;
    currentMark.height = height;
    
    if (currentMark.element) {
        currentMark.element.style.left = `${x}px`;
        currentMark.element.style.top = `${y}px`;
        currentMark.element.style.width = `${width}px`;
        currentMark.element.style.height = `${height}px`;
    }
}

// å®Œæˆæ¨™è¨˜
function finishMark(e) {
    if (!currentMark) return;
    
    document.removeEventListener('mousemove', updateMark, true);
    document.removeEventListener('mouseup', finishMark, true);
    document.removeEventListener('touchmove', updateMark, true);
    document.removeEventListener('touchend', finishMark, true);
    
    if (currentMark.width > 10 && currentMark.height > 10) {
        // ä¿å­˜æ¨™è¨˜
        if (!marks[currentMark.pageNum]) {
            marks[currentMark.pageNum] = [];
        }
        marks[currentMark.pageNum].push({
            id: currentMark.id,
            x: currentMark.x,
            y: currentMark.y,
            width: currentMark.width,
            height: currentMark.height,
            text: '' // å°‡åœ¨é»æ“Šæ™‚æå–
        });
        
        // ä¿å­˜æ¨™è¨˜IDå’Œé ç¢¼åˆ°è®Šé‡ä¸­ï¼Œé¿å…é–‰åŒ…å•é¡Œ
        const markId = currentMark.id;
        const markPageNum = currentMark.pageNum;
        
        // æ·»åŠ é»æ“Šäº‹ä»¶ï¼ˆé»æ“Šå€å¡Šæ™‚æœ—è®€ï¼‰
        currentMark.element.addEventListener('click', (e) => {
            // å¦‚æœé»æ“Šçš„æ˜¯åˆªé™¤æŒ‰éˆ•ï¼Œä¸è§¸ç™¼æœ—è®€
            if (e.target.classList.contains('mark-delete')) {
                return;
            }
            e.stopPropagation();
            readMarkBlock(markId, markPageNum);
        });
        
        // æ·»åŠ åˆªé™¤æŒ‰éˆ•
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'mark-delete';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.title = 'åˆªé™¤æ­¤æ¨™è¨˜';
        deleteBtn.style.pointerEvents = 'auto';
        deleteBtn.style.zIndex = '1002';
        
        // ä½¿ç”¨å¤šç¨®äº‹ä»¶ç¢ºä¿èƒ½è§¸ç™¼ï¼Œä½¿ç”¨ä¿å­˜çš„è®Šé‡è€Œä¸æ˜¯ currentMark
        const handleDelete = (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('åˆªé™¤æŒ‰éˆ•è¢«é»æ“Šï¼Œæ¨™è¨˜ID:', markId);
            deleteMarkBlock(markId, markPageNum);
            return false;
        };
        
        deleteBtn.addEventListener('mousedown', handleDelete);
        deleteBtn.addEventListener('touchstart', handleDelete);
        deleteBtn.addEventListener('click', handleDelete);
        
        currentMark.element.appendChild(deleteBtn);
        
    } else {
        // æ¨™è¨˜å¤ªå°ï¼Œç§»é™¤
        if (currentMark.element) {
            currentMark.element.remove();
        }
    }
    
    currentMark = null;
}

// æœ—è®€æ¨™è¨˜å€å¡Š
async function readMarkBlock(markId, pageNum) {
    const mark = marks[pageNum]?.find(m => m.id === markId);
    if (!mark) return;
    
    // ç²å–æ¨™è¨˜å±¤å’Œæ–‡å­—å±¤
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${pageNum}"]`);
    if (!markLayer) return;
    
    // æ‰¾åˆ°èˆ‡æ¨™è¨˜å±¤åŒä¸€å€‹ pdfViewer ä¸­çš„æ–‡å­—å±¤
    const pdfViewer = markLayer.parentElement;
    if (!pdfViewer) return;
    
    const textLayer = pdfViewer.querySelector('.textLayer');
    
    // æå–æ¨™è¨˜å€åŸŸå…§çš„æ–‡å­—ï¼ˆå¦‚æœæœ‰æ–‡å­—å±¤ï¼‰
    let text = '';
    let cleanedText = '';
    const markLayerRect = markLayer.getBoundingClientRect();
    
    if (textLayer) {
        const textLayerRect = textLayer.getBoundingClientRect();
        const spans = textLayer.getElementsByTagName('my-fra');
        
        // è¨ˆç®—æ¨™è¨˜åœ¨æ–‡å­—å±¤ä¸­çš„å¯¦éš›ä½ç½®ï¼ˆè€ƒæ…®æ¨™è¨˜å±¤å’Œæ–‡å­—å±¤çš„ç›¸å°ä½ç½®ï¼‰
        const markInTextLayer = {
            left: mark.x + (markLayerRect.left - textLayerRect.left),
            top: mark.y + (markLayerRect.top - textLayerRect.top),
            right: mark.x + mark.width + (markLayerRect.left - textLayerRect.left),
            bottom: mark.y + mark.height + (markLayerRect.top - textLayerRect.top)
        };
        
        for (let span of spans) {
            const spanRect = span.getBoundingClientRect();
            
            // è¨ˆç®— span åœ¨æ–‡å­—å±¤ä¸­çš„ä½ç½®
            const spanX = spanRect.left - textLayerRect.left;
            const spanY = spanRect.top - textLayerRect.top;
            const spanRight = spanRect.right - textLayerRect.left;
            const spanBottom = spanRect.bottom - textLayerRect.top;
            
            // æª¢æŸ¥ span æ˜¯å¦èˆ‡æ¨™è¨˜å€åŸŸé‡ç–Šï¼ˆä½¿ç”¨æ›´å¯¬é¬†çš„é‡ç–Šåˆ¤æ–·ï¼‰
            const isOverlapping = !(spanRight < markInTextLayer.left || 
                                    spanX > markInTextLayer.right ||
                                    spanBottom < markInTextLayer.top ||
                                    spanY > markInTextLayer.bottom);
            
            if (isOverlapping) {
                text += span.textContent;
            }
        }
        
        // æ¸…ç†æ–‡å­—ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
        cleanedText = text.trim().replace(/[\r\n]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
    }
    
    // å–å¾—åœ–ç‰‡ base64ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    let base64Image = null;
    let croppedCanvas = null;
    const pdfCanvas = pdfViewer.querySelector('canvas');
    if (pdfCanvas) {
        // è¨ˆç®—æ¨™è¨˜åœ¨ç•«å¸ƒä¸­çš„å¯¦éš›ä½ç½®ï¼ˆä½¿ç”¨ getBoundingClientRectï¼Œèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
        const markBlockElement = markLayer.querySelector(`[data-mark-id="${markId}"]`);
        if (markBlockElement) {
            const markBlockRect = markBlockElement.getBoundingClientRect();
            // ç¢ºä¿ cropCanvas å‡½æ•¸å¯ç”¨ï¼ˆæª¢æŸ¥å…¨å±€ä½œç”¨åŸŸï¼‰
            const cropCanvasFunc = typeof window !== 'undefined' && window.cropCanvas ? window.cropCanvas : (typeof cropCanvas !== 'undefined' ? cropCanvas : null);
            if (cropCanvasFunc && typeof cropCanvasFunc === 'function') {
                croppedCanvas = cropCanvasFunc(pdfCanvas, markBlockRect);
                if (croppedCanvas) {
                    const canvasToBase64Func = typeof window !== 'undefined' && window.canvasToBase64 ? window.canvasToBase64 : (typeof canvasToBase64 !== 'undefined' ? canvasToBase64 : null);
                    if (canvasToBase64Func && typeof canvasToBase64Func === 'function') {
                        base64Image = canvasToBase64Func(croppedCanvas);
                    }
                }
            } else {
                console.error('cropCanvas å‡½æ•¸æœªå®šç¾©ï¼Œè«‹ç¢ºä¿å‡½æ•¸å·²æ­£ç¢ºè¼‰å…¥');
            }
        }
    }
    
    // åˆ¤æ–·æ˜¯å¦æœ‰åœ–ç‰‡å…§å®¹ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    let hasImageContent = false;
    if (croppedCanvas) {
        const isCanvasAllWhiteFunc = window.isCanvasAllWhite || isCanvasAllWhite;
        if (typeof isCanvasAllWhiteFunc === 'function' && !isCanvasAllWhiteFunc(croppedCanvas)) {
            hasImageContent = true;
        }
    }
    
    // åˆ¤æ–·å…§å®¹ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    if (!hasImageContent && cleanedText.length === 0) {
        Swal.fire({
            icon: 'warning',
            title: 'æ²’æœ‰å…§å®¹',
            text: 'æ¨™è¨˜å€åŸŸå…§æ²’æœ‰æ–‡å­—æˆ–åœ–ç‰‡'
        });
        return;
    }
    
    // åªè¦æœ‰ PDF æ–‡å­—å±¤ï¼Œå°±åªæœ—è®€ç´”æ–‡å­—ï¼Œä¸é€åœ–ç‰‡çµ¦ AIï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    if (cleanedText.length > 0) {
        text = cleanedText;
    } else if (hasImageContent && base64Image) {
        // æ²’æœ‰ PDF æ–‡å­—å±¤ï¼Œæ‰é€åœ–ç‰‡çµ¦ AIï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼Œåƒè€ƒ readTextInsideFrame çš„é‚è¼¯ï¼‰
        // å¦‚æœæ­£åœ¨é€²è¡Œåœ–ç‰‡è¾¨è­˜ï¼Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
        if (typeof isImageRecognizing !== 'undefined' && isImageRecognizing) {
            console.log('åœ–ç‰‡è¾¨è­˜æ­£åœ¨é€²è¡Œä¸­ï¼Œå¿½ç•¥é‡è¤‡è«‹æ±‚');
            return;
        }
        
        // è¨­ç½®æ¨™è¨˜ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
        if (typeof isImageRecognizing !== 'undefined') {
            isImageRecognizing = true;
        }
        
        // åœ¨ iOS ä¸Šï¼Œéœ€è¦åœ¨ç”¨æˆ¶äº¤äº’çš„åŒæ­¥ä¸Šä¸‹æ–‡ä¸­ç«‹å³ç²å–éŸ³é »æ’­æ”¾æ¬Šé™
        // é€šéæ’­æ”¾"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚"ä¾†ç²å–æ¬Šé™ï¼ŒåŒæ™‚çµ¦ç”¨æˆ¶æç¤º
        // é˜²æ­¢é‡è¤‡æ’­æ”¾
        if (typeof isPlayingWaitingMessage !== 'undefined' && !isPlayingWaitingMessage) {
            isPlayingWaitingMessage = true;
            const ttsFunction = window.sendTextToTTS || sendTextToTTS;
            if (typeof ttsFunction === 'function') {
                ttsFunction('åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚', () => {
                    console.log('æ’­æ”¾æ¬Šé™å·²ç²å–ï¼Œé–‹å§‹åœ–ç‰‡è¾¨è­˜');
                    if (typeof isPlayingWaitingMessage !== 'undefined') {
                        isPlayingWaitingMessage = false; // æ’­æ”¾å®Œæˆå¾Œé‡ç½®æ¨™è¨˜
                    }
                });
            } else {
                if (typeof isPlayingWaitingMessage !== 'undefined') {
                    isPlayingWaitingMessage = false;
                }
            }
        }
        
        try {
            Swal.fire({
                title: 'æ­£åœ¨è¾¨è­˜åœ–ç‰‡',
                text: 'æ­£åœ¨ä½¿ç”¨ AI è¾¨è­˜åœ–ç‰‡å…§å®¹...ï¼ˆGeminiï¼‰',
                allowOutsideClick: false,
                customClass: {
                    popup: 'swal-high-z-index'
                },
                didOpen: () => {
                    Swal.showLoading();
                }
            });
            // ç¢ºä¿ geminiImageDescribe å‡½æ•¸å¯ç”¨
            const geminiImageDescribeFunc = typeof window !== 'undefined' && window.geminiImageDescribe ? window.geminiImageDescribe : (typeof geminiImageDescribe !== 'undefined' ? geminiImageDescribe : null);
            if (!geminiImageDescribeFunc || typeof geminiImageDescribeFunc !== 'function') {
                Swal.close();
                console.error('geminiImageDescribe å‡½æ•¸æœªå®šç¾©');
                Swal.fire({
                    icon: 'error',
                    title: 'è¾¨è­˜å¤±æ•—',
                    text: 'åœ–ç‰‡è¾¨è­˜å‡½æ•¸æœªè¼‰å…¥ï¼Œè«‹åˆ·æ–°é é¢å¾Œé‡è©¦'
                });
                if (typeof isImageRecognizing !== 'undefined') {
                    isImageRecognizing = false;
                }
                if (typeof isPlayingWaitingMessage !== 'undefined') {
                    isPlayingWaitingMessage = false;
                }
                return;
            }
            const aiDescription = await geminiImageDescribeFunc(base64Image);
            Swal.close();
            if (aiDescription && aiDescription.length > 0) {
                // ç­‰å¾…"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚"æ’­æ”¾å®Œæˆï¼ˆæˆ–è‡³å°‘ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿æ¬Šé™å·²ç²å–ï¼‰
                // å¦‚æœé‚„åœ¨æ’­æ”¾ï¼Œåœæ­¢å®ƒ
                const audioPlayer = document.getElementById('audioPlayer');
                if (audioPlayer && !audioPlayer.paused) {
                    audioPlayer.pause();
                    audioPlayer.currentTime = 0;
                }
                
                // ç›´æ¥ä½¿ç”¨ Gemini åŸå§‹å›å‚³ï¼Œç›´æ¥èª¿ç”¨ sendTextToTTS æœ—è®€ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
                // æ­¤æ™‚å·²ç¶“ç²å–äº†æ’­æ”¾æ¬Šé™ï¼Œå¯ä»¥è‡ªå‹•æ’­æ”¾
                const ttsFunction = window.sendTextToTTS || sendTextToTTS;
                if (typeof ttsFunction === 'function') {
                    ttsFunction(aiDescription, () => {
                        console.log('åœ–ç‰‡è¾¨è­˜æ–‡å­—æœ—è®€å®Œæˆ');
                        // è¾¨è­˜å®Œæˆï¼Œé‡ç½®æ¨™è¨˜
                        if (typeof isImageRecognizing !== 'undefined') {
                            isImageRecognizing = false;
                        }
                        if (typeof isPlayingWaitingMessage !== 'undefined') {
                            isPlayingWaitingMessage = false;
                        }
                    });
                }
                // åœ–ç‰‡è¾¨è­˜å®Œæˆå¾Œç›´æ¥è¿”å›ï¼Œä¸é€²å…¥å¾ŒçºŒçš„æ–‡å­—æœ—è®€æµç¨‹
                return;
            } else {
                console.error('Gemini å›å‚³çš„å…§å®¹ç‚ºç©º');
                Swal.fire({
                    icon: 'warning',
                    title: 'è¾¨è­˜çµæœç‚ºç©º',
                    text: 'AI ç„¡æ³•è¾¨è­˜åœ–ç‰‡å…§å®¹'
                });
                // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
                if (typeof isImageRecognizing !== 'undefined') {
                    isImageRecognizing = false;
                }
                if (typeof isPlayingWaitingMessage !== 'undefined') {
                    isPlayingWaitingMessage = false;
                }
                return;
            }
        } catch (error) {
            Swal.close();
            console.error('Gemini è¾¨è­˜å¤±æ•—:', error);
            Swal.fire({
                icon: 'error',
                title: 'è¾¨è­˜å¤±æ•—',
                text: 'AI è¾¨è­˜éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ã€‚'
            });
            // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
            if (typeof isImageRecognizing !== 'undefined') {
                isImageRecognizing = false;
            }
            if (typeof isPlayingWaitingMessage !== 'undefined') {
                isPlayingWaitingMessage = false;
            }
            return;
        }
    } else if (hasImageContent && !base64Image) {
        // æœ‰åœ–ç‰‡å…§å®¹ä½† base64Image ç‚º nullï¼Œå¯èƒ½æ˜¯è£å‰ªå¤±æ•—
        console.error('ç„¡æ³•ç²å–åœ–ç‰‡ base64ï¼Œå¯èƒ½è£å‰ªå¤±æ•—');
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•è¾¨è­˜',
            text: 'ç„¡æ³•ç²å–æ¨™è¨˜å€åŸŸçš„åœ–ç‰‡å…§å®¹ï¼Œè«‹ç¢ºä¿æ¨™è¨˜å€åŸŸåŒ…å«åœ–ç‰‡'
        });
        return;
    }
    
    if (text.trim()) {
        // é«˜äº®é¡¯ç¤ºæ¨™è¨˜
        const markElement = markLayer.querySelector(`[data-mark-id="${markId}"]`);
        if (markElement) {
            markElement.classList.add('active');
        }
        
        // å°‡æ¨™è¨˜å€åŸŸå…§çš„æ–‡å­—èƒŒæ™¯è®Šæˆæ·¡é»ƒè‰²ï¼ˆåƒ…åœ¨æœ‰æ–‡å­—å±¤æ™‚ï¼‰
        const highlightedSpans = [];
        if (textLayer) {
            const textLayerRect = textLayer.getBoundingClientRect();
            const markLayerRect = markLayer.getBoundingClientRect();
            const spans = textLayer.getElementsByTagName('my-fra');
            
            // è¨ˆç®—æ¨™è¨˜åœ¨æ–‡å­—å±¤ä¸­çš„å¯¦éš›ä½ç½®
            const markInTextLayer = {
                left: mark.x + (markLayerRect.left - textLayerRect.left),
                top: mark.y + (markLayerRect.top - textLayerRect.top),
                right: mark.x + mark.width + (markLayerRect.left - textLayerRect.left),
                bottom: mark.y + mark.height + (markLayerRect.top - textLayerRect.top)
            };
            
            for (let span of spans) {
                const spanRect = span.getBoundingClientRect();
                const spanX = spanRect.left - textLayerRect.left;
                const spanY = spanRect.top - textLayerRect.top;
                const spanRight = spanRect.right - textLayerRect.left;
                const spanBottom = spanRect.bottom - textLayerRect.top;
                
                // æª¢æŸ¥ span æ˜¯å¦èˆ‡æ¨™è¨˜å€åŸŸé‡ç–Š
                const isOverlapping = !(spanRight < markInTextLayer.left || 
                                    spanX > markInTextLayer.right ||
                                    spanBottom < markInTextLayer.top ||
                                    spanY > markInTextLayer.bottom);
                
                if (isOverlapping) {
                    // ä¿å­˜åŸå§‹èƒŒæ™¯è‰²ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
                    const originalBg = span.style.backgroundColor;
                    highlightedSpans.push({ span, originalBg });
                    // è¨­ç½®æ·¡é»ƒè‰²èƒŒæ™¯ï¼ˆä¸æ“‹ä½å…§å®¹ï¼Œä½¿ç”¨åŠé€æ˜ï¼‰
                    span.style.backgroundColor = 'rgba(255, 255, 200, 0.4)';
                }
            }
        }
        
        // ç™¼é€æ–‡å­—çµ¦TTSæœ—è®€
        await new Promise((resolve) => {
            // ä½¿ç”¨å…¨å±€çš„ sendTextToTTS å‡½æ•¸
            const ttsFunction = window.sendTextToTTS || sendTextToTTS;
            if (typeof ttsFunction === 'function') {
                ttsFunction(text.trim(), () => {
                    // æœ—è®€å®Œæˆå¾Œï¼Œæ¸…é™¤æ–‡å­—èƒŒæ™¯è‰²
                    highlightedSpans.forEach(({ span, originalBg }) => {
                        if (originalBg) {
                            span.style.backgroundColor = originalBg;
                        } else {
                            span.style.backgroundColor = '';
                        }
                    });
                    // æ¸…é™¤æ¨™è¨˜å…ƒç´ çš„é«˜äº®
                    if (markElement) {
                        markElement.classList.remove('active');
                    }
                    resolve();
                });
            } else {
                console.error('sendTextToTTS å‡½æ•¸æœªå®šç¾©ï¼Œè«‹æª¢æŸ¥å‡½æ•¸æ˜¯å¦å·²æ­£ç¢ºè¼‰å…¥');
                // æ¸…é™¤æ–‡å­—èƒŒæ™¯è‰²
                highlightedSpans.forEach(({ span, originalBg }) => {
                    if (originalBg) {
                        span.style.backgroundColor = originalBg;
                    } else {
                        span.style.backgroundColor = '';
                    }
                });
                // æ¸…é™¤æ¨™è¨˜å…ƒç´ çš„é«˜äº®
                if (markElement) {
                    markElement.classList.remove('active');
                }
                Swal.fire({
                    icon: 'error',
                    title: 'æœ—è®€å¤±æ•—',
                    text: 'TTS å‡½æ•¸æœªè¼‰å…¥ï¼Œè«‹åˆ·æ–°é é¢å¾Œé‡è©¦'
                });
                resolve();
            }
        });
    } else {
        Swal.fire({
            icon: 'warning',
            title: 'æ²’æœ‰å…§å®¹',
            text: 'æ­¤å€å¡Šå…§æ²’æœ‰å¯æœ—è®€çš„æ–‡å­—æˆ–åœ–ç‰‡'
        });
    }
}

// åˆªé™¤å–®å€‹æ¨™è¨˜å€å¡Š
function deleteMarkBlock(markId, pageNum) {
    console.log('deleteMarkBlock è¢«èª¿ç”¨ï¼ŒmarkId:', markId, 'pageNum:', pageNum);
    
    if (!marks[pageNum]) {
        console.warn('è©²é æ²’æœ‰æ¨™è¨˜:', pageNum);
        return;
    }
    
    // ç›´æ¥åˆªé™¤ï¼Œä¸é¡¯ç¤ºç¢ºèªå°è©±æ¡†ï¼ˆå› ç‚ºç”¨æˆ¶å·²ç¶“é»æ“Šäº†åˆªé™¤æŒ‰éˆ•ï¼‰
    // å¾æ¨™è¨˜æ•¸çµ„ä¸­ç§»é™¤
    const originalLength = marks[pageNum].length;
    marks[pageNum] = marks[pageNum].filter(m => m.id !== markId);
    
    if (marks[pageNum].length === originalLength) {
        console.warn('æœªæ‰¾åˆ°è¦åˆªé™¤çš„æ¨™è¨˜ï¼ŒmarkId:', markId);
        return;
    }
    
    // å¦‚æœè©²é æ²’æœ‰æ¨™è¨˜äº†ï¼Œåˆªé™¤è©²é çš„æ¨™è¨˜æ•¸çµ„
    if (marks[pageNum].length === 0) {
        delete marks[pageNum];
    }
    
    // é‡æ–°æ¸²æŸ“æ¨™è¨˜
    renderMarks();
    
    console.log('æ¨™è¨˜å·²åˆªé™¤ï¼ŒmarkId:', markId);
}

// æ¨™è¨˜é¡¯ç¤ºç‹€æ…‹
let marksVisible = false;

// åˆ‡æ›æ¨™è¨˜é¡¯ç¤º/éš±è—
function toggleMarksVisibility() {
    marksVisible = !marksVisible;
    const toggleButton = document.getElementById('toggleMarksButton');
    const markLayers = document.querySelectorAll('.mark-layer');
    
    if (marksVisible) {
        toggleButton.textContent = 'éš±è—æ¨™è¨˜';
        markLayers.forEach(layer => {
            layer.classList.remove('hidden');
        });
    } else {
        toggleButton.textContent = 'é¡¯ç¤ºæ¨™è¨˜';
        markLayers.forEach(layer => {
            layer.classList.add('hidden');
        });
    }
}

// æ›´æ–°æ¨™è¨˜å¯è¦‹æ€§
function updateMarksVisibility() {
    const markLayers = document.querySelectorAll('.mark-layer');
    const toggleButton = document.getElementById('toggleMarksButton');
    
    if (toggleButton) {
        if (marksVisible) {
            markLayers.forEach(layer => {
                layer.classList.remove('hidden');
            });
        } else {
            markLayers.forEach(layer => {
                layer.classList.add('hidden');
            });
        }
    }
}


// å¾PDFæ–‡ä»¶è¼‰å…¥æ¨™è¨˜ï¼ˆå¾PDFå…ƒæ•¸æ“šä¸­è®€å–ï¼‰
async function loadMarksFromPdf() {
    try {
        if (!originalPdfBytes) {
            console.warn('originalPdfBytes æœªè¨­ç½®ï¼Œç„¡æ³•è¼‰å…¥æ¨™è¨˜');
            marks = {};
            return;
        }
        
        if (typeof PDFLib === 'undefined') {
            console.warn('PDFLib æœªè¼‰å…¥ï¼Œç­‰å¾…è¼‰å…¥...');
            // ç­‰å¾… PDFLib è¼‰å…¥
            let retryCount = 0;
            const maxRetries = 50; // æœ€å¤šç­‰å¾…5ç§’
            const checkPDFLib = setInterval(() => {
                retryCount++;
                if (typeof PDFLib !== 'undefined') {
                    clearInterval(checkPDFLib);
                    loadMarksFromPdf(); // é‡æ–°èª¿ç”¨
                } else if (retryCount >= maxRetries) {
                    clearInterval(checkPDFLib);
                    console.error('PDFLib è¼‰å…¥è¶…æ™‚ï¼Œç„¡æ³•è¼‰å…¥æ¨™è¨˜');
                    marks = {};
                }
            }, 100);
            return;
        }
        
        console.log('é–‹å§‹å¾PDFè¼‰å…¥æ¨™è¨˜ï¼ŒoriginalPdfBytesé•·åº¦:', originalPdfBytes.length);
        
        const { PDFDocument } = PDFLib;
        const pdfDocLib = await PDFDocument.load(originalPdfBytes);
        
        // å¾PDFçš„Subjectæ¬„ä½è®€å–æ¨™è¨˜æ•¸æ“š
        const subject = pdfDocLib.getSubject() || '';
        
        console.log('PDF Subject:', subject.substring(0, 50) + '...'); // åªé¡¯ç¤ºå‰50å€‹å­—ç¬¦
        
        if (subject.startsWith('PDF_MARKS_DATA:')) {
            // æå–æ¨™è¨˜æ•¸æ“š
            const encodedMarks = subject.substring('PDF_MARKS_DATA:'.length);
            try {
                const marksJson = decodeURIComponent(escape(atob(encodedMarks)));
                marks = JSON.parse(marksJson);
                
                console.log('å¾PDFæ–‡ä»¶è¼‰å…¥æ¨™è¨˜æ•¸æ“šæˆåŠŸï¼Œæ¨™è¨˜æ•¸é‡:', Object.keys(marks).length);
                
                // æ¨™è¨˜æ•¸æ“šå·²è¼‰å…¥ï¼Œä½†ä¸è‡ªå‹•é¡¯ç¤ºæ¨™è¨˜å’Œç·¨è¼¯æŒ‰éˆ•
                // åªæœ‰é€²å…¥ç·¨è¼¯æ¨¡å¼æ™‚æ‰é¡¯ç¤ºæ¨™è¨˜å’Œç·¨è¼¯åŠŸèƒ½
                console.log('æ¨™è¨˜æ•¸æ“šå·²è¼‰å…¥ï¼Œç­‰å¾…é€²å…¥ç·¨è¼¯æ¨¡å¼å¾Œé¡¯ç¤º');
                
                // å»¶é²æ¸²æŸ“æ¨™è¨˜ï¼ˆä½†æ¨™è¨˜æœƒéš±è—ï¼Œç›´åˆ°é€²å…¥ç·¨è¼¯æ¨¡å¼ï¼‰
                setTimeout(() => {
                    renderMarks();
                }, 500);
            } catch (parseError) {
                console.error('è§£æPDFä¸­çš„æ¨™è¨˜æ•¸æ“šå¤±æ•—:', parseError);
                console.error('ç·¨ç¢¼çš„æ¨™è¨˜æ•¸æ“š:', encodedMarks.substring(0, 100));
                // PDFä¸­æ²’æœ‰æ¨™è¨˜æ•¸æ“šæˆ–è§£æå¤±æ•—ï¼Œæ¨™è¨˜ç‚ºç©º
                marks = {};
            }
        } else {
            // PDFä¸­æ²’æœ‰æ¨™è¨˜æ•¸æ“šï¼Œæ¨™è¨˜ç‚ºç©º
            console.log('PDFä¸­æ²’æœ‰æ¨™è¨˜æ•¸æ“š');
            marks = {};
        }
    } catch (error) {
        console.error('å¾PDFè¼‰å…¥æ¨™è¨˜å¤±æ•—:', error);
        console.error('éŒ¯èª¤è©³æƒ…:', error.stack);
        // è¼‰å…¥å¤±æ•—ï¼Œæ¨™è¨˜ç‚ºç©º
        marks = {};
    }
}

// æ¸²æŸ“æ¨™è¨˜
function renderMarks() {
    if (!marks[currentPage] || marks[currentPage].length === 0) {
        // æ¸…é™¤æ¨™è¨˜å±¤å…§å®¹
        const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
        if (markLayer) {
            markLayer.innerHTML = '';
        }
        return;
    }
    
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
    if (!markLayer) {
        console.warn('æ¨™è¨˜å±¤ä¸å­˜åœ¨ï¼Œé ç¢¼:', currentPage);
        return;
    }
    
    // æ¸…é™¤èˆŠçš„æ¨™è¨˜
    markLayer.innerHTML = '';
    
    marks[currentPage].forEach(mark => {
        // é©—è­‰æ¨™è¨˜æ•¸æ“š
        if (!mark || typeof mark.x !== 'number' || typeof mark.y !== 'number' || 
            typeof mark.width !== 'number' || typeof mark.height !== 'number') {
            console.warn('ç„¡æ•ˆçš„æ¨™è¨˜æ•¸æ“š:', mark);
            return;
        }
        
        // ç¢ºä¿æ¨™è¨˜å°ºå¯¸åˆç†
        if (mark.width <= 0 || mark.height <= 0) {
            console.warn('æ¨™è¨˜å°ºå¯¸ç„¡æ•ˆ:', mark);
            return;
        }
        
        const markBlock = document.createElement('div');
        markBlock.className = 'mark-block';
        markBlock.dataset.markId = mark.id;
        markBlock.style.position = 'absolute';
        markBlock.style.left = `${mark.x}px`;
        markBlock.style.top = `${mark.y}px`;
        markBlock.style.width = `${mark.width}px`;
        markBlock.style.height = `${mark.height}px`;
        markBlock.style.display = 'block';
        markBlock.style.visibility = 'visible';
        
        const label = document.createElement('div');
        label.className = 'mark-label';
        label.textContent = `å€å¡Š ${mark.id + 1}`;
        markBlock.appendChild(label);
        
        // æ·»åŠ åˆªé™¤æŒ‰éˆ•
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'mark-delete';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.title = 'åˆªé™¤æ­¤æ¨™è¨˜';
        deleteBtn.style.pointerEvents = 'auto';
        deleteBtn.style.zIndex = '1002';
        
        // ä½¿ç”¨ mousedown äº‹ä»¶ç¢ºä¿èƒ½è§¸ç™¼
        deleteBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('åˆªé™¤æŒ‰éˆ•è¢«é»æ“Šï¼Œæ¨™è¨˜ID:', mark.id);
            deleteMarkBlock(mark.id, currentPage);
            return false;
        });
        
        deleteBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('åˆªé™¤æŒ‰éˆ•è¢«è§¸æ‘¸ï¼Œæ¨™è¨˜ID:', mark.id);
            deleteMarkBlock(mark.id, currentPage);
            return false;
        });
        
        deleteBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('åˆªé™¤æŒ‰éˆ•è¢«é»æ“Šï¼ˆclickäº‹ä»¶ï¼‰ï¼Œæ¨™è¨˜ID:', mark.id);
            deleteMarkBlock(mark.id, currentPage);
            return false;
        });
        
        markBlock.appendChild(deleteBtn);
        
        // é»æ“Šå€å¡Šæ™‚æœ—è®€ï¼ˆæ’é™¤åˆªé™¤æŒ‰éˆ•ï¼‰
        // ç„¡è«–æ¨™è¨˜æ˜¯å¦å¯è¦‹ï¼Œéƒ½è¦ä¿ç•™é»æ“Šæœ—è®€åŠŸèƒ½
        markBlock.addEventListener('click', (e) => {
            // å¦‚æœé»æ“Šçš„æ˜¯åˆªé™¤æŒ‰éˆ•æˆ–å…¶å­å…ƒç´ ï¼Œä¸è§¸ç™¼æœ—è®€
            if (e.target.classList.contains('mark-delete') || 
                e.target.closest('.mark-delete')) {
                e.stopPropagation();
                return;
            }
            // ç„¡è«–æ˜¯å¦åœ¨ç·¨è¼¯æ¨¡å¼ï¼Œé»æ“Šæ¨™è¨˜å€åŸŸéƒ½è§¸ç™¼æœ—è®€
            e.stopPropagation();
            readMarkBlock(mark.id, currentPage);
        });
        
        markLayer.appendChild(markBlock);
    });
    
    // æ›´æ–°æœ€å¤§IDè¨ˆæ•¸å™¨
    const allMarks = Object.values(marks).flat();
    if (allMarks.length > 0) {
        markIdCounter = Math.max(...allMarks.map(m => m.id)) + 1;
    }
    
    // æ ¹æ“šæ˜¯å¦åœ¨ç·¨è¼¯æ¨¡å¼ä¾†æ±ºå®šæ¨™è¨˜çš„å¯è¦‹æ€§
    if (isMarkingMode) {
        // ç·¨è¼¯æ¨¡å¼ï¼šé¡¯ç¤ºæ‰€æœ‰æ¨™è¨˜
        const markBlocks = markLayer.querySelectorAll('.mark-block');
        markBlocks.forEach(block => {
            block.style.display = 'block';
            block.style.visibility = 'visible';
            block.style.opacity = '1';
            block.style.pointerEvents = 'auto';
            // æ¢å¾©é‚Šæ¡†å’ŒèƒŒæ™¯è‰²
            block.style.border = '3px solid #007BFF';
            block.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            // é¡¯ç¤ºæ¨™ç±¤å’Œåˆªé™¤æŒ‰éˆ•
            const label = block.querySelector('.mark-label');
            const deleteBtn = block.querySelector('.mark-delete');
            if (label) {
                label.style.display = 'block';
            }
            if (deleteBtn) {
                deleteBtn.style.display = 'flex';
            }
        });
        markLayer.classList.remove('hidden');
        markLayer.style.pointerEvents = 'none'; // æ¨™è¨˜å±¤ä¸æ¥æ”¶äº‹ä»¶ï¼Œä½†æ¨™è¨˜å€å¡Šå¯ä»¥
    } else {
        // éç·¨è¼¯æ¨¡å¼ï¼šéš±è—æ¨™è¨˜è¦–è¦ºï¼Œä½†ä¿ç•™é»æ“ŠåŠŸèƒ½
        const markBlocks = markLayer.querySelectorAll('.mark-block');
        markBlocks.forEach(block => {
            block.style.display = 'block'; // ä¿ç•™å…ƒç´ ä»¥ä¾¿é»æ“Š
            block.style.visibility = 'visible';
            block.style.opacity = '0'; // è¦–è¦ºä¸Šä¸å¯è¦‹
            block.style.pointerEvents = 'auto'; // ä¿ç•™é»æ“ŠåŠŸèƒ½
            block.style.backgroundColor = 'transparent'; // ç¢ºä¿èƒŒæ™¯é€æ˜
            block.style.border = 'none'; // éš±è—é‚Šæ¡†
            // éš±è—æ¨™ç±¤å’Œåˆªé™¤æŒ‰éˆ•
            const label = block.querySelector('.mark-label');
            const deleteBtn = block.querySelector('.mark-delete');
            if (label) label.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
        });
        markLayer.classList.remove('hidden'); // æ¨™è¨˜å±¤éœ€è¦å­˜åœ¨ä»¥ä¾¿é»æ“Š
        markLayer.style.pointerEvents = 'none'; // æ¨™è¨˜å±¤ä¸æ¥æ”¶äº‹ä»¶ï¼Œä½†æ¨™è¨˜å€å¡Šå¯ä»¥
    }
}

// ä¿å­˜æ¨™è¨˜åˆ°PDFï¼ˆå°‡æ¨™è¨˜æ•¸æ“šä¿å­˜åˆ°PDFå…ƒæ•¸æ“šä¸­ï¼‰
async function saveMarksToPdf() {
    if (!pdfDoc || !originalPdfBytes) {
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•ä¿å­˜',
            text: 'è«‹å…ˆè¼‰å…¥PDFæª”æ¡ˆ'
        });
        return;
    }
    
    // æª¢æŸ¥ PDFLib æ˜¯å¦å·²è¼‰å…¥
    if (typeof PDFLib === 'undefined') {
        Swal.fire({
            icon: 'error',
            title: 'åº«æœªè¼‰å…¥',
            text: 'PDF-lib åº«å°šæœªè¼‰å…¥ï¼Œè«‹åˆ·æ–°é é¢å¾Œé‡è©¦'
        });
        return;
    }
    
    try {
        Swal.fire({
            title: 'æ­£åœ¨ä¿å­˜',
            text: 'æ­£åœ¨å°‡æ¨™è¨˜ä¿å­˜åˆ°PDF...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });
        
        const { PDFDocument } = PDFLib;
        const pdfDocLib = await PDFDocument.load(originalPdfBytes);
        
        // å°‡æ¨™è¨˜æ•¸æ“šè½‰æ›ç‚ºJSONå­—ç¬¦ä¸²
        const marksJson = JSON.stringify(marks);
        
        // å°‡æ¨™è¨˜æ•¸æ“šä¿å­˜åˆ°PDFçš„å…ƒæ•¸æ“šä¸­ï¼ˆä½¿ç”¨è‡ªå®šç¾©å±¬æ€§ï¼‰
        // ä½¿ç”¨ Subject æ¬„ä½ä¾†å­˜å„²æ¨™è¨˜æ•¸æ“šï¼ˆå› ç‚ºé€™æ˜¯æ¨™æº–å…ƒæ•¸æ“šæ¬„ä½ï¼Œä¸æœƒå½±éŸ¿PDFé¡¯ç¤ºï¼‰
        const existingSubject = pdfDocLib.getSubject() || '';
        
        // å‰µå»ºä¸€å€‹åŒ…å«æ¨™è¨˜æ•¸æ“šçš„å°è±¡ï¼Œä½¿ç”¨ç‰¹æ®Šæ¨™è¨˜ä¾†è­˜åˆ¥
        const marksMetadata = {
            pdfMarks: marksJson,
            version: '1.0'
        };
        
        // å°‡æ¨™è¨˜æ•¸æ“šç·¨ç¢¼å¾Œå­˜å„²åˆ°PDFçš„Subjectæ¬„ä½
        // ä½¿ç”¨base64ç·¨ç¢¼ä»¥é¿å…ç‰¹æ®Šå­—ç¬¦å•é¡Œ
        const encodedMarks = btoa(unescape(encodeURIComponent(marksJson)));
        pdfDocLib.setSubject(`PDF_MARKS_DATA:${encodedMarks}`);
        
        // ä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå®šç¾©å±¬æ€§ï¼ˆå¦‚æœPDF-libæ”¯æŒï¼‰
        // ä¿å­˜æ›´æ–°å¾Œçš„PDFå­—ç¯€
        const pdfBytes = await pdfDocLib.save();
        originalPdfBytes = pdfBytes;
        
        // æ›´æ–°IndexedDBä¸­çš„PDF
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const urlParams = new URLSearchParams(window.location.search);
        const fileParam = urlParams.get('file');
        const fileName = fileParam || 'marked_document.pdf';
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        Swal.fire({
            icon: 'success',
            title: 'ä¿å­˜æˆåŠŸ',
            text: 'æ¨™è¨˜å·²ä¿å­˜åˆ°PDFæ–‡ä»¶ä¸­ï¼Œå¯ç¹¼çºŒç·¨è¼¯',
            timer: 1500,
            showConfirmButton: false
        });
        
        // ä¿å­˜å¾Œä¸éš±è—æ¨™è¨˜ï¼Œä¿æŒå¯è¦‹ä»¥ä¾¿ç¹¼çºŒç·¨è¼¯
    } catch (error) {
        console.error('ä¿å­˜æ¨™è¨˜åˆ°PDFå¤±æ•—:', error);
        Swal.fire({
            icon: 'error',
            title: 'ä¿å­˜å¤±æ•—',
            text: 'ç„¡æ³•ä¿å­˜æ¨™è¨˜åˆ°PDF: ' + error.message
        });
    }
}

// ä¸‹è¼‰åŒ…å«æ¨™è¨˜çš„PDF
async function downloadMarkedPdf() {
    if (!originalPdfBytes) {
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•ä¸‹è¼‰',
            text: 'è«‹å…ˆä¿å­˜æ¨™è¨˜åˆ°PDF'
        });
        return;
    }
    
    try {
        // ç¢ºä¿æ¨™è¨˜æ•¸æ“šå·²ä¿å­˜åˆ°PDFæ–‡ä»¶
        await saveMarksToPdf();
        
        // ä¸‹è¼‰åŸå§‹PDFï¼ˆä¸åŒ…å«æ¨™è¨˜æ¡†ç·šï¼‰
        const blob = new Blob([originalPdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        const urlParams = new URLSearchParams(window.location.search);
        const fileParam = urlParams.get('file');
        let fileName = fileParam || 'document.pdf';
        
        // åœ¨æª”åå¾ŒåŠ ä¸Šã€Œå·²æ¨™ç¤ºã€å¾Œç¶´ï¼ˆå¦‚æœé‚„æ²’æœ‰ï¼‰
        if (!fileName.includes('å·²æ¨™ç¤º')) {
            const lastDotIndex = fileName.lastIndexOf('.');
            if (lastDotIndex > 0) {
                // æœ‰å‰¯æª”åï¼Œåœ¨å‰¯æª”åå‰æ’å…¥ã€Œå·²æ¨™ç¤ºã€
                fileName = fileName.substring(0, lastDotIndex) + '_å·²æ¨™ç¤º' + fileName.substring(lastDotIndex);
            } else {
                // æ²’æœ‰å‰¯æª”åï¼Œç›´æ¥åŠ ä¸Šã€Œå·²æ¨™ç¤ºã€
                fileName = fileName + '_å·²æ¨™ç¤º';
            }
        }
        
        a.download = fileName;
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        Swal.fire({
            icon: 'success',
            title: 'ä¸‹è¼‰æˆåŠŸ',
            text: 'PDFå·²ä¸‹è¼‰åˆ°æœ¬åœ°ï¼ˆæ¨™è¨˜æ•¸æ“šå·²ä¿å­˜ï¼Œé‡æ–°è¼‰å…¥æ­¤PDFæ™‚æœƒè‡ªå‹•æ¢å¾©æ¨™è¨˜ï¼‰',
            timer: 2000,
            showConfirmButton: false
        });
    } catch (error) {
        console.error('ä¸‹è¼‰PDFå¤±æ•—:', error);
        Swal.fire({
            icon: 'error',
            title: 'ä¸‹è¼‰å¤±æ•—',
            text: 'ç„¡æ³•ä¸‹è¼‰PDF: ' + error.message
        });
    }
}

// æ¸…é™¤æ‰€æœ‰æ¨™è¨˜
function clearAllMarks() {
    Swal.fire({
        icon: 'warning',
        title: 'ç¢ºèªæ¸…é™¤',
        text: 'ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ¨™è¨˜å—ï¼Ÿ',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®š',
        cancelButtonText: 'å–æ¶ˆ'
    }).then((result) => {
        if (result.isConfirmed) {
            marks = {};
            markIdCounter = 0;
            const markLayers = document.querySelectorAll('.mark-layer');
            markLayers.forEach(layer => {
                layer.innerHTML = '';
            });
            // æ¸…é™¤æ¨™è¨˜å¾Œï¼Œéœ€è¦ä¿å­˜åˆ°PDFä»¥æ›´æ–°PDFæ–‡ä»¶
            if (typeof PDFLib !== 'undefined' && originalPdfBytes) {
                saveMarksToPdf();
            }
            Swal.fire({
                icon: 'success',
                title: 'å·²æ¸…é™¤',
                text: 'æ‰€æœ‰æ¨™è¨˜å·²æ¸…é™¤',
                timer: 1500,
                showConfirmButton: false
            });
        }
    });
}

// åœ¨PDFè¼‰å…¥æ™‚ä¿å­˜åŸå§‹å­—ç¯€
async function saveOriginalPdfBytes(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        originalPdfBytes = new Uint8Array(arrayBuffer);
    } catch (error) {
        console.error('ä¿å­˜åŸå§‹PDFå­—ç¯€å¤±æ•—:', error);
    }
}

// æ·»åŠ æ¨™è¨˜äº‹ä»¶ç›£è½å™¨
document.addEventListener('DOMContentLoaded', () => {
    // ç­‰å¾… PDFLib è¼‰å…¥å®Œæˆ
    const checkPDFLib = setInterval(() => {
        if (typeof PDFLib !== 'undefined') {
            clearInterval(checkPDFLib);
            initMarkingFeature();
            
            // åœ¨æ¨™è¨˜å±¤ä¸Šæ·»åŠ æ¨™è¨˜äº‹ä»¶ï¼ˆå‹•æ…‹ç¶å®šï¼Œå› ç‚ºæ¨™è¨˜å±¤æ˜¯å‹•æ…‹å‰µå»ºçš„ï¼‰
            // æ¨™è¨˜äº‹ä»¶å·²åœ¨å‰µå»ºæ¨™è¨˜å±¤æ™‚ç¶å®š
        }
    }, 100);
    
    // 10ç§’å¾Œåœæ­¢æª¢æŸ¥
    setTimeout(() => {
        clearInterval(checkPDFLib);
        if (typeof PDFLib === 'undefined') {
            console.warn('PDFLib æœªè¼‰å…¥ï¼Œæ¨™è¨˜åŠŸèƒ½å¯èƒ½ç„¡æ³•ä½¿ç”¨');
            // å³ä½¿ PDFLib æœªè¼‰å…¥ï¼Œä¹Ÿåˆå§‹åŒ–åŸºæœ¬åŠŸèƒ½ï¼ˆæ¨™è¨˜å’Œæœ—è®€ä»å¯ä½¿ç”¨ï¼‰
            initMarkingFeature();
        }
    }, 10000);
});
        
</script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@latest/dist/tesseract.min.js"></script>
</body>
</html>